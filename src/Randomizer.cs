using Tavenem.Randomize.Distributions;
using Tavenem.Randomize.Generators;

namespace Tavenem.Randomize;

/// <summary>
/// Provides random number generation and selection capabilities.
/// </summary>
public class Randomizer
{
    private readonly RandomNumberGenerator _generator;

    /// <summary>
    /// A static instance of <see cref="Randomizer"/>.
    /// </summary>
    /// <remarks>
    /// Unless your use-case has requirements which prohibit doing so, randomization is improved
    /// when using a single, shared static instance. The underlying pseudo-random number
    /// generator performs nearly twice as well, and generates better quality results (more
    /// closely approximating randomness) when it generates successive values from the same seed
    /// without being reinitialized. Generating a new instance of <see cref="Randomizer"/> on
    /// demand will still produce reasonably random results, since automatically generated seeds
    /// are themselves pseudo-random (<seealso cref="SeedGenerator.GetNewSeed()"/>). However,
    /// the quality of these "one-off" results will be lower than the quality of successive
    /// values generated by a generator instance which is not reinitialized between runs.
    /// </remarks>
    public static readonly Randomizer Instance = new();

    /// <summary>
    /// The seed value.
    /// </summary>
    public uint Seed
    {
        get => _generator.Seed;
        set => Reset(value);
    }

    /// <summary>
    /// Initializes a new instance of <see cref="Randomizer"/> with the given seed.
    /// </summary>
    /// <param name="seed">The initial seed.</param>
    public Randomizer(uint seed) => _generator = new RandomNumberGenerator(seed);

    /// <summary>
    /// Initializes a new instance of <see cref="Randomizer"/> with a pseudo-random seed.
    /// </summary>
    public Randomizer() => _generator = new RandomNumberGenerator();

    /// <summary>
    /// <para>
    /// Gets a sample pseudo-random value from a binomial distribution.
    /// </para>
    /// <para>
    /// When generating multiple values, use <see cref="BinomialDistributionSamples(int, uint,
    /// double)"/>.
    /// </para>
    /// <para>
    /// If a single trial is generated (the default), gives the Bernoulli distribution.
    /// </para>
    /// </summary>
    /// <param name="n">
    /// <para>
    /// The sample size (number of trials). [0, <see cref="uint.MaxValue"/>]
    /// </para>
    /// <para>
    /// The default of 1 trial gives the Bernoulli distribution.
    /// </para>
    /// </param>
    /// <param name="p">
    /// <para>
    /// The normalized probability of an individual success. [0, 1]
    /// </para>
    /// <para>
    /// This value will be truncated to a valid value if it exceeds the allowable bounds.
    /// </para>
    /// </param>
    /// <returns>A sample pseudo-random value from a binomial distribution.</returns>
    public uint BinomialDistributionSample(uint n = 1, double p = 0.5)
        => BinomialDistribution.Samples(_generator, 1, n, p).First();

    /// <summary>
    /// <para>
    /// Enumerates sample pseudo-random values from a binomial distribution.
    /// </para>
    /// <para>
    /// If a single trial is generated (the default), gives the Bernoulli distribution.
    /// </para>
    /// </summary>
    /// <param name="numberOfSamples">
    /// <para>
    /// The number of sample values to generate. This parameter ensures that operations like
    /// <see cref="Enumerable.ToList"/> will not cause an overflow, by preventing an
    /// infinite enumeration. If more than <see cref="int.MaxValue"/> samples are required, this
    /// method can be called again to "refresh" the count.
    /// </para>
    /// <para>
    /// Values less than zero will be treated as zero.
    /// </para>
    /// </param>
    /// <param name="n">
    /// <para>
    /// The sample size (number of trials). [0, <see cref="uint.MaxValue"/>]
    /// </para>
    /// <para>
    /// The default of 1 trial gives the Bernoulli distribution.
    /// </para>
    /// </param>
    /// <param name="p">
    /// <para>
    /// The normalized probability of an individual success. [0, 1]
    /// </para>
    /// <para>
    /// This value will be truncated to a valid value if it exceeds the allowable bounds.
    /// </para>
    /// </param>
    /// <returns>An <see cref="IEnumerable{T}"/> of sample pseudo-random values from a binomial
    /// distribution.</returns>
    public IEnumerable<uint> BinomialDistributionSamples(int numberOfSamples = 1, uint n = 1, double p = 0.5)
        => BinomialDistribution.Samples(_generator, numberOfSamples, n, p);

    /// <summary>
    /// <para>
    /// Gets a sample pseudo-random value from a categorical (discrete) distribution.
    /// </para>
    /// <para>
    /// When generating multiple values, use <see cref="CategoricalDistributionSamples(int,
    /// int)"/>.
    /// </para>
    /// </summary>
    /// <param name="k">
    /// <para>
    /// The number of equal-weight categories. (0, <see cref="int.MaxValue"/>].
    /// </para>
    /// <para>
    /// A value less than or equal to zero will be treated as a 1.
    /// </para>
    /// </param>
    /// <returns>A sample value from a categorical (discrete) distribution.</returns>
    public int CategoricalDistributionSample(int k)
        => CategoricalDistribution.Samples(k, _generator, 1).First();

    /// <summary>
    /// <para>
    /// Gets a sample pseudo-random value from a categorical (discrete) distribution.
    /// </para>
    /// <para>
    /// When generating multiple values, use <see cref="CategoricalDistributionSamples(int,
    /// ICollection{double})"/>.
    /// </para>
    /// </summary>
    /// <param name="weights">
    /// <para>
    /// The normalized probability vector of the categorical distribution.
    /// </para>
    /// <para>
    /// Values do not need to be pre-normalized. They will be normalized if necessary.
    /// </para>
    /// <para>
    /// Any weights which are negative are treated as 0.
    /// </para>
    /// <para>
    /// If <see langword="null"/> or empty, a default set of 3 equal weights will be used.
    /// </para>
    /// </param>
    /// <returns>A sample value from a categorical (discrete) distribution.</returns>
    /// <exception cref="ArgumentException">
    /// The <paramref name="weights"/> collection sums to zero.
    /// </exception>
    public int CategoricalDistributionSample(IEnumerable<double>? weights = null)
        => CategoricalDistribution.Samples(_generator, 1, weights).First();

    /// <summary>
    /// Enumerates sample pseudo-random values from a categorical (discrete) distribution.
    /// </summary>
    /// <param name="k">
    /// <para>
    /// The number of equal-weight categories. (0, <see cref="int.MaxValue"/>].
    /// </para>
    /// <para>
    /// A value less than or equal to zero will be treated as a 1.
    /// </para>
    /// </param>
    /// <param name="numberOfSamples">
    /// <para>
    /// The number of sample values to generate. This parameter ensures that operations like
    /// <see cref="Enumerable.ToList"/> will not cause an overflow, by preventing an
    /// infinite enumeration. If more than <see cref="int.MaxValue"/> samples are required, this
    /// method can be called again to "refresh" the count.
    /// </para>
    /// <para>
    /// Values less than zero will be treated as zero.
    /// </para>
    /// </param>
    /// <returns>An <see cref="IEnumerable{T}"/> of sample values from a categorical (discrete)
    /// distribution.</returns>
    public IEnumerable<int> CategoricalDistributionSamples(int k, int numberOfSamples = 1)
        => CategoricalDistribution.Samples(k, _generator, numberOfSamples);

    /// <summary>
    /// Enumerates sample pseudo-random values from a categorical (discrete) distribution.
    /// </summary>
    /// <param name="numberOfSamples">
    /// <para>
    /// The number of sample values to generate. This parameter ensures that operations like
    /// <see cref="Enumerable.ToList"/> will not cause an overflow, by preventing an
    /// infinite enumeration. If more than <see cref="int.MaxValue"/> samples are required, this
    /// method can be called again to "refresh" the count.
    /// </para>
    /// <para>
    /// Values less than zero will be treated as zero.
    /// </para>
    /// </param>
    /// <param name="weights">
    /// <para>
    /// The normalized probability vector of the categorical distribution.
    /// </para>
    /// <para>
    /// Values do not need to be pre-normalized. They will be normalized if necessary.
    /// </para>
    /// <para>
    /// Any weights which are negative are treated as 0.
    /// </para>
    /// <para>
    /// If <see langword="null"/> or empty, a default set of 3 equal weights will be used.
    /// </para>
    /// </param>
    /// <returns>An <see cref="IEnumerable{T}"/> of sample values from a categorical (discrete)
    /// distribution.</returns>
    /// <exception cref="ArgumentException">
    /// The <paramref name="weights"/> collection sums to zero.
    /// </exception>
    public IEnumerable<int> CategoricalDistributionSamples(int numberOfSamples = 1, ICollection<double>? weights = null)
        => CategoricalDistribution.Samples(_generator, numberOfSamples, weights);

    /// <summary>
    /// <para>
    /// Gets a sample pseudo-random value from an exponential distribution.
    /// </para>
    /// <para>
    /// When generating multiple values, use <see cref="ExponentialDistributionSamples(int,
    /// double, double?)"/>.
    /// </para>
    /// </summary>
    /// <param name="lambda">
    /// <para>
    /// The parameter of the distribution (rate parameter). (0, ∞)
    /// </para>
    /// <para>
    /// If <see cref="double.NaN"/>, all results will be <see cref="double.NaN"/>.
    /// </para>
    /// <para>
    /// If less than or equal to zero, will be set to the smallest value recognized as greater
    /// than zero in this library (<see cref="NumberValues.NearlyZeroDouble"/>).
    /// </para>
    /// </param>
    /// <param name="maximum">
    /// <para>
    /// A maximum value. Does not affect the shape of the function, but results greater than
    /// this value will not be generated. [0, ∞)
    /// </para>
    /// <para>
    /// Values less than 0 are treated as 0.
    /// </para>
    /// </param>
    /// <returns>A sample value from an exponential distribution.</returns>
    public double ExponentialDistributionSample(double lambda = 1, double? maximum = null)
        => ExponentialDistribution.Samples(_generator, 1, lambda, maximum).First();

    /// <summary>
    /// Enumerates sample pseudo-random values from an exponential distribution.
    /// </summary>
    /// <param name="numberOfSamples">
    /// <para>
    /// The number of sample values to generate. This parameter ensures that operations like
    /// <see cref="Enumerable.ToList"/> will not cause an overflow, by preventing an
    /// infinite enumeration. If more than <see cref="int.MaxValue"/> samples are required, this
    /// method can be called again to "refresh" the count.
    /// </para>
    /// <para>
    /// Values less than zero will be treated as zero.
    /// </para>
    /// </param>
    /// <param name="lambda">
    /// <para>
    /// The parameter of the distribution (rate parameter). (0, ∞)
    /// </para>
    /// <para>
    /// If <see cref="double.NaN"/>, all results will be <see cref="double.NaN"/>.
    /// </para>
    /// <para>
    /// If less than or equal to zero, will be set to the smallest value recognized as greater
    /// than zero in this library (<see cref="NumberValues.NearlyZeroDouble"/>).
    /// </para>
    /// </param>
    /// <param name="maximum">
    /// <para>
    /// A maximum value. Does not affect the shape of the function, but results greater than
    /// this value will not be generated. [0, ∞)
    /// </para>
    /// <para>
    /// Values less than 0 are treated as 0.
    /// </para>
    /// </param>
    /// <returns>An <see cref="IEnumerable{T}"/> of sample values from an exponential
    /// distribution.</returns>
    public IEnumerable<double> ExponentialDistributionSamples(int numberOfSamples = 1, double lambda = 1, double? maximum = null)
        => ExponentialDistribution.Samples(_generator, numberOfSamples, lambda, maximum);

    /// <summary>
    /// <para>
    /// Gets a sample pseudo-random value from a logistic distribution.
    /// </para>
    /// <para>
    /// When generating multiple values, use <see cref="LogisticDistributionSamples(int, double,
    /// double, double?, double?)"/>.
    /// </para>
    /// </summary>
    /// <param name="mu">
    /// <para>
    /// The location (mean) of the distribution.
    /// </para>
    /// <para>
    /// If <see cref="double.NaN"/>, all results will be <see cref="double.NaN"/>.
    /// </para>
    /// </param>
    /// <param name="sigma">
    /// <para>
    /// The scale of the distribution. (0, ∞)
    /// </para>
    /// <para>
    /// If <see cref="double.NaN"/>, all results will be <see cref="double.NaN"/>.
    /// </para>
    /// <para>
    /// If less than or equal to zero, will be set to the smallest value recognized as greater
    /// than zero in this library (<see cref="NumberValues.NearlyZeroDouble"/>).
    /// </para>
    /// </param>
    /// <param name="minimum">
    /// <para>
    /// A minimum value. Does not affect the shape of the function, but results less than this
    /// value will not be generated.
    /// </para>
    /// </param>
    /// <param name="maximum">
    /// <para>
    /// A maximum value. Does not affect the shape of the function, but results greater than
    /// this value will not be generated.
    /// </para>
    /// </param>
    /// <returns>A sample value from a logistic distribution.</returns>
    /// <remarks>
    /// If <paramref name="minimum"/> and <paramref name="maximum"/> are both non-<see
    /// langword="null"/> and <paramref name="minimum" /> is greater than <paramref
    /// name="maximum" />, the result is determined by <see
    /// cref="RandomizeOptions.InvalidFloatingRangeResult" />.
    /// </remarks>
    public double LogisticDistributionSample(
        double mu = 0,
        double sigma = 1,
        double? minimum = null,
        double? maximum = null)
        => LogisticDistribution.Samples(_generator, 1, mu, sigma, minimum, maximum).First();

    /// <summary>
    /// Enumerates sample pseudo-random values from a logistic distribution.
    /// </summary>
    /// <param name="numberOfSamples">
    /// <para>
    /// The number of sample values to generate. This parameter ensures that operations like
    /// <see cref="Enumerable.ToList"/> will not cause an overflow, by preventing an
    /// infinite enumeration. If more than <see cref="int.MaxValue"/> samples are required, this
    /// method can be called again to "refresh" the count.
    /// </para>
    /// <para>
    /// Values less than zero will be treated as zero.
    /// </para>
    /// </param>
    /// <param name="mu">
    /// <para>
    /// The location (mean) of the distribution.
    /// </para>
    /// <para>
    /// If <see cref="double.NaN"/>, all results will be <see cref="double.NaN"/>.
    /// </para>
    /// </param>
    /// <param name="sigma">
    /// <para>
    /// The scale of the distribution. (0, ∞)
    /// </para>
    /// <para>
    /// If <see cref="double.NaN"/>, all results will be <see cref="double.NaN"/>.
    /// </para>
    /// <para>
    /// If less than or equal to zero, will be set to the smallest value recognized as greater
    /// than zero in this library (<see cref="NumberValues.NearlyZeroDouble"/>).
    /// </para>
    /// </param>
    /// <param name="minimum">
    /// <para>
    /// A minimum value. Does not affect the shape of the function, but results less than this
    /// value will not be generated.
    /// </para>
    /// </param>
    /// <param name="maximum">
    /// <para>
    /// A maximum value. Does not affect the shape of the function, but results greater than
    /// this value will not be generated.
    /// </para>
    /// </param>
    /// <returns>An <see cref="IEnumerable{T}"/> of sample values from a logistic
    /// distribution.</returns>
    /// <remarks>
    /// If <paramref name="minimum"/> and <paramref name="maximum"/> are both non-<see
    /// langword="null"/> and <paramref name="minimum" /> is greater than <paramref
    /// name="maximum" />, the result is determined by <see
    /// cref="RandomizeOptions.InvalidFloatingRangeResult" />.
    /// </remarks>
    public IEnumerable<double> LogisticDistributionSamples(
        int numberOfSamples = 1,
        double mu = 0,
        double sigma = 1,
        double? minimum = null,
        double? maximum = null)
        => LogisticDistribution.Samples(_generator, numberOfSamples, mu, sigma, minimum, maximum);

    /// <summary>
    /// <para>
    /// Gets a sample pseudo-random value from a log-normal distribution.
    /// </para>
    /// <para>
    /// When generating multiple values, use <see cref="LogNormalDistributionSamples(int,
    /// double, double, double?, double?)"/>.
    /// </para>
    /// </summary>
    /// <param name="mu">
    /// <para>
    /// The location (mean) of the distribution.
    /// </para>
    /// <para>
    /// If <see cref="double.NaN"/>, all results will be <see cref="double.NaN"/>.
    /// </para>
    /// </param>
    /// <param name="sigma">
    /// <para>
    /// The scale of the distribution. (0, ∞)
    /// </para>
    /// <para>
    /// If <see cref="double.NaN"/>, all results will be <see cref="double.NaN"/>.
    /// </para>
    /// <para>
    /// If less than or equal to zero, will be set to the smallest value recognized as greater
    /// than zero in this library (<see cref="NumberValues.NearlyZeroDouble"/>).
    /// </para>
    /// </param>
    /// <param name="minimum">
    /// <para>
    /// A minimum value. Does not affect the shape of the function, but results less than this
    /// value will not be generated.
    /// </para>
    /// </param>
    /// <param name="maximum">
    /// <para>
    /// A maximum value. Does not affect the shape of the function, but results greater than
    /// this value will not be generated.
    /// </para>
    /// </param>
    /// <returns>A sample value from a log-normal distribution.</returns>
    /// <remarks>
    /// If <paramref name="minimum"/> and <paramref name="maximum"/> are both non-<see
    /// langword="null"/> and <paramref name="minimum" /> is greater than <paramref
    /// name="maximum" />, the result is determined by <see
    /// cref="RandomizeOptions.InvalidFloatingRangeResult" />.
    /// </remarks>
    public double LogNormalDistributionSample(
        double mu = 0,
        double sigma = 1,
        double? minimum = null,
        double? maximum = null)
        => LogNormalDistribution.Samples(_generator, 1, mu, sigma, minimum, maximum).First();

    /// <summary>
    /// Enumerates sample pseudo-random values from a log-normal distribution.
    /// </summary>
    /// <param name="numberOfSamples">
    /// <para>
    /// The number of sample values to generate. This parameter ensures that operations like
    /// <see cref="Enumerable.ToList"/> will not cause an overflow, by preventing an
    /// infinite enumeration. If more than <see cref="int.MaxValue"/> samples are required, this
    /// method can be called again to "refresh" the count.
    /// </para>
    /// <para>
    /// Values less than zero will be treated as zero.
    /// </para>
    /// </param>
    /// <param name="mu">
    /// <para>
    /// The location (mean) of the distribution.
    /// </para>
    /// <para>
    /// If <see cref="double.NaN"/>, all results will be <see cref="double.NaN"/>.
    /// </para>
    /// </param>
    /// <param name="sigma">
    /// <para>
    /// The scale of the distribution. (0, ∞)
    /// </para>
    /// <para>
    /// If <see cref="double.NaN"/>, all results will be <see cref="double.NaN"/>.
    /// </para>
    /// <para>
    /// If less than or equal to zero, will be set to the smallest value recognized as greater
    /// than zero in this library (<see cref="NumberValues.NearlyZeroDouble"/>).
    /// </para>
    /// </param>
    /// <param name="minimum">
    /// <para>
    /// A minimum value. Does not affect the shape of the function, but results less than this
    /// value will not be generated.
    /// </para>
    /// </param>
    /// <param name="maximum">
    /// <para>
    /// A maximum value. Does not affect the shape of the function, but results greater than
    /// this value will not be generated.
    /// </para>
    /// </param>
    /// <returns>An <see cref="IEnumerable{T}"/> of sample values from a log-normal
    /// distribution.</returns>
    /// <remarks>
    /// If <paramref name="minimum"/> and <paramref name="maximum"/> are both non-<see
    /// langword="null"/> and <paramref name="minimum" /> is greater than <paramref
    /// name="maximum" />, the result is determined by <see
    /// cref="RandomizeOptions.InvalidFloatingRangeResult" />.
    /// </remarks>
    public IEnumerable<double> LogNormalDistributionSamples(
        int numberOfSamples = 1,
        double mu = 0,
        double sigma = 1,
        double? minimum = null,
        double? maximum = null)
        => LogNormalDistribution.Samples(_generator, numberOfSamples, mu, sigma, minimum, maximum);

    /// <summary>
    /// Gets a random, nonnegative integer less than <see cref="int.MaxValue" />.
    /// </summary>
    /// <returns>A random, nonnegative integer less than <see cref="int.MaxValue" />.</returns>
    public int Next() => _generator.Next();

    /// <summary>
    /// Gets a random, nonnegative integer less than <paramref name="maxValue" />.
    /// </summary>
    /// <param name="maxValue">
    /// <para>
    /// The exclusive maximum bound of the random number to be generated.
    /// </para>
    /// <para>
    /// If this value is negative, it is considered an exclusive minimum bound instead (and zero
    /// becomes the inclusive maximum bound).
    /// </para>
    /// </param>
    /// <returns>A random, nonnegative integer less than <paramref name="maxValue" />.</returns>
    public int Next(int maxValue) => _generator.Next(maxValue);

    /// <summary>
    /// Gets a random integer greater than or equal to <paramref name="minValue" />
    /// and less than <paramref name="maxValue" />.
    /// </summary>
    /// <param name="minValue">The inclusive minimum bound of the random number to be
    /// generated.</param>
    /// <param name="maxValue">The exclusive maximum bound of the random number to be
    /// generated.</param>
    /// <returns>A random integer greater than or equal to <paramref name="minValue" /> and less
    /// than <paramref name="maxValue" />.</returns>
    /// <remarks>
    /// If <paramref name="minValue" /> is greater than <paramref name="maxValue" />, the result
    /// is determined by <see cref="RandomizeOptions.InvalidIntegralRangeResult" />.
    /// </remarks>
    public int Next(int minValue, int maxValue) => _generator.Next(minValue, maxValue);

    /// <summary>
    /// Gets a random, nonnegative floating-point number less than 1.
    /// </summary>
    /// <returns>A random, nonnegative floating-point number less than 1.</returns>
    public T Next<T>() where T : IFloatingPoint<T> => _generator.Next<T>();

    /// <summary>
    /// Gets a random floating-point number between zero and <paramref name="maxValue"/>.
    /// </summary>
    /// <param name="maxValue">
    /// <para>
    /// The exclusive maximum bound of the random number to be generated.
    /// </para>
    /// <para>
    /// If this value is negative, it is considered an exclusive minimum bound instead (and zero
    /// becomes the inclusive maximum bound).
    /// </para>
    /// <para>
    /// If the value satisfies <see cref="INumberBase{TSelf}.IsNaN(TSelf)"/> the result will be the
    /// result of 0/0 (normally <see cref="IFloatingPointIeee754{TSelf}.NaN"/>, but this might
    /// result in an exception if <typeparamref name="T"/> does not implement <see
    /// cref="IFloatingPointIeee754{TSelf}"/>).
    /// </para>
    /// <para>
    /// If the value is positive or negative infinity, it will always be returned as the result.
    /// </para>
    /// </param>
    /// <returns>A random, nonnegative floating-point number less than <paramref
    /// name="maxValue"/>.</returns>
    public T Next<T>(T maxValue) where T : IFloatingPoint<T> => _generator.Next(maxValue);

    /// <summary>
    /// Gets a random floating-point number greater than or equal to <paramref name="minValue"/>
    /// and less than or equal to <paramref name="maxValue"/>.
    /// </summary>
    /// <param name="minValue">
    /// <para>
    /// The inclusive minimum bound of the random number to be generated.
    /// </para>
    /// <para>
    /// If the value satisfies <see cref="INumberBase{TSelf}.IsNaN(TSelf)"/> the result will be <see
    /// cref="IFloatingPointIeee754{TSelf}.NaN"/>.
    /// </para>
    /// <para>
    /// If the value is positive or negative infinity, it will always be returned as the result
    /// unless <paramref name="maxValue"/> is the opposing infinity (in which case either
    /// positive or negative infinity will be returned randomly).
    /// </para>
    /// </param>
    /// <param name="maxValue">
    /// <para>
    /// The exclusive maximum bound of the random number to be generated.
    /// </para>
    /// <para>
    /// If the value satisfies <see cref="INumberBase{TSelf}.IsNaN(TSelf)"/> the result will be <see
    /// cref="IFloatingPointIeee754{TSelf}.NaN"/>.
    /// </para>
    /// <para>
    /// If the value is positive or negative infinity, it will always be returned as the result
    /// unless <paramref name="minValue"/> is the opposing infinity (in which case either
    /// positive or negative infinity will be returned randomly).
    /// </para>
    /// </param>
    /// <returns>A random, nonnegative floating-point number greater than or equal to <paramref
    /// name="minValue"/> and less than <paramref name="maxValue"/>.</returns>
    /// <remarks>
    /// If <paramref name="minValue"/> is greater than <paramref name="maxValue"/>, the result
    /// is determined by <see cref="RandomizeOptions.InvalidFloatingRangeResult"/>.
    /// </remarks>
    public T Next<T>(T minValue, T maxValue) where T : IFloatingPointIeee754<T> => _generator.Next(minValue, maxValue);

    /// <summary>
    /// <para>
    /// Gets a random element from the given <see cref="IList{T}"/>.
    /// </para>
    /// <para>
    /// Each element has an equal chance of being selected. To select elements according to a
    /// weighted distribution, use <see cref="Next{T}(IList{T}, Func{T, double})"/>. Note that if
    /// you are generating multiple results, it is more efficient to instead call <see
    /// cref="CategoricalDistributionSamples(int, ICollection{double})"/> with the collection of
    /// weights as the parameter, and take the results as indexes to selected items in the
    /// <paramref name="list"/>.
    /// </para>
    /// <para>
    /// To select an index rather than an element, use <see cref="NextIndex{T}(IList{T})"/>.
    /// </para>
    /// </summary>
    /// <typeparam name="T">The type of elements in the list.</typeparam>
    /// <param name="list">An <see cref="IList{T}"/>.</param>
    /// <returns>
    /// A randomly-selected element from <paramref name="list"/>, or the default value of
    /// <typeparamref name="T"/> if <paramref name="list"/> is <see langword="null"/> or
    /// contains no elements.
    /// </returns>
    public T? Next<T>(IList<T>? list) => (list?.Count ?? 0) == 0 ? default : list![Next(list.Count)];

    /// <summary>
    /// <para>
    /// Gets a random element from the given <see cref="IList{T}"/>, where each element has a
    /// weighted chance of selected, given by the function provided.
    /// </para>
    /// <para>
    /// To select elements at random from an unweighted collection, use <see
    /// cref="Next{T}(IList{T})"/>.
    /// </para>
    /// <para>
    /// Note that if you are generating multiple results, it is more efficient to instead call
    /// <see cref="CategoricalDistributionSamples(int, ICollection{double})"/> with the
    /// collection of weights as the parameter, and take the results as indexes to selected
    /// items in the <paramref name="list"/>.
    /// </para>
    /// <para>
    /// To select an index rather than an element, use <see cref="NextIndex{T}(IList{T}, Func{T,
    /// double})"/>.
    /// </para>
    /// </summary>
    /// <typeparam name="T">The type of elements in the list.</typeparam>
    /// <param name="list">An <see cref="IList{T}"/>.</param>
    /// <param name="weightFunction">A function which provides a weight, given an element in the
    /// <paramref name="list"/>.</param>
    /// <returns>
    /// A randomly-selected element from <paramref name="list"/>, or the default value of
    /// <typeparamref name="T"/> if <paramref name="list"/> is <see langword="null"/> or
    /// contains no elements.
    /// </returns>
    public T? Next<T>(IList<T>? list, Func<T, double> weightFunction)
        => (list?.Count ?? 0) == 0
            ? default
            : list![CategoricalDistributionSample(list.Select(weightFunction).ToList())];

    /// <summary>
    /// <para>
    /// Gets a random element from the given <see cref="IEnumerable{T}"/>, in which each
    /// successive item has <paramref name="selectionChance"/> probability of being chosen.
    /// </para>
    /// <para>
    /// Note that this does not result in every item having an equal probability of being
    /// selected. The larger your collection, the lower the probability that items near the end
    /// of the collection will be selected, as each item preceding them will have had a chance
    /// to be selected. To instead select items with equal probability, call <see
    /// cref="Next{T}(IList{T})"/> on the enumerated elements of your collection.
    /// </para>
    /// </summary>
    /// <typeparam name="T">The type of elements in the list.</typeparam>
    /// <param name="enumerable">An <see cref="IEnumerable{T}"/>.</param>
    /// <param name="selectionChance">
    /// <para>
    /// The probability of selecting any given element. [0, 1]
    /// </para>
    /// <para>
    /// Values less than 0 will be treated as 0, and values greater than 1 will be treated as 1.
    /// </para>
    /// </param>
    /// <returns>
    /// A randomly-selected element from <paramref name="enumerable"/>, or the default value of
    /// <typeparamref name="T"/> if <paramref name="enumerable"/> is <see langword="null"/> or
    /// contains no elements.
    /// </returns>
    public T? Next<T>(IEnumerable<T>? enumerable, double selectionChance)
    {
        T? current = default;
        if (enumerable != null)
        {
            foreach (var item in enumerable)
            {
                if (NextBool(selectionChance))
                {
                    return item;
                }
                current = item;
            }
        }
        return current;
    }

    /// <summary>
    /// <para>
    /// Gets a random value according to the given <paramref name="parameters"/>.
    /// </para>
    /// <para>
    /// Note that in most cases, calling the other methods of this class directly is more
    /// efficient than using <see cref="RandomParameters"/>. This is especially true if multiple
    /// values are retrieved in a series.
    /// </para>
    /// </summary>
    /// <param name="parameters">A <see cref="RandomParameters"/> instance.</param>
    /// <returns>A random value.</returns>
    /// <remarks>
    /// <para>
    /// This method allows generation of random values according to a parameter object instead
    /// of calling the more specific methods directly. Doing so is much less efficient, and in
    /// many cases involves rounding, boxing and unboxing of parameters and return values, and
    /// frequent <see langword="null"/> checks.
    /// </para>
    /// <para>
    /// This option is provided to facilitate generation of random values on demand based on
    /// parameters which must be serialized, whether for storage or transmission over the wire.
    /// Whenever possible it is preferable to call the other, more specific methods of this
    /// class directly, using their appropriate parameters.
    /// </para>
    /// </remarks>
    public double Next(RandomParameters parameters)
    {
        double result;
        var precision = parameters.Precision;
        switch (parameters.DistributionType)
        {
            case DistributionType.ContinuousUniform:
                if (parameters.Minimum.HasValue)
                {
                    result = NextDouble(parameters.Minimum.Value, parameters.Maximum ?? double.PositiveInfinity);
                }
                else if (parameters.Maximum.HasValue)
                {
                    result = NextDouble(parameters.Maximum.Value);
                }
                else
                {
                    result = NextDouble();
                }
                break;
            case DistributionType.DiscreteUniformSigned:
                if (parameters.Minimum.HasValue)
                {
                    result = NextInclusive(
                        (int)Math.Round(parameters.Minimum.Value),
                        parameters.Maximum.HasValue
                            ? (int)Math.Round(parameters.Maximum.Value)
                            : int.MaxValue);
                }
                else if (parameters.Maximum.HasValue)
                {
                    result = NextInclusive(int.MinValue, (int)Math.Round(parameters.Maximum.Value));
                }
                else
                {
                    result = NextInclusive(int.MinValue, int.MaxValue);
                }
                precision = 0;
                break;
            case DistributionType.DiscreteUniformUnsigned:
                if (parameters.Minimum.HasValue)
                {
                    result = NextUIntInclusive(
                        (uint)Math.Round(parameters.Minimum.Value),
                        parameters.Maximum.HasValue
                            ? (uint)Math.Round(parameters.Maximum.Value)
                            : uint.MaxValue);
                }
                else if (parameters.Maximum.HasValue)
                {
                    result = NextUIntInclusive(uint.MinValue, (uint)Math.Round(parameters.Maximum.Value));
                }
                else
                {
                    result = NextUIntInclusive(uint.MinValue, uint.MaxValue);
                }
                precision = 0;
                break;
            case DistributionType.Binomial:
                result = BinomialDistributionSample(
                    parameters.SampleSize ?? 1,
                    parameters.Probability ?? 0.5);
                precision = 0;
                break;
            case DistributionType.Categorical:
                result = CategoricalDistributionSample(parameters.Weights);
                precision = 0;
                break;
            case DistributionType.PositiveNormal:
                result = PositiveNormalDistributionSample(
                    parameters.Mu ?? 0,
                    parameters.Sigma ?? 1,
                    parameters.Maximum);
                break;
            case DistributionType.Exponential:
                result = ExponentialDistributionSample(
                    parameters.Lambda ?? 1,
                    parameters.Maximum);
                break;
            case DistributionType.LogNormal:
                result = LogNormalDistributionSample(
                    parameters.Mu ?? 0,
                    parameters.Sigma ?? 1,
                    parameters.Minimum,
                    parameters.Maximum);
                break;
            case DistributionType.Logistic:
                result = LogisticDistributionSample(
                    parameters.Mu ?? 0,
                    parameters.Sigma ?? 1,
                    parameters.Minimum,
                    parameters.Maximum);
                break;
            case DistributionType.Normal:
                result = NormalDistributionSample(
                    parameters.Mu ?? 0,
                    parameters.Sigma ?? 1,
                    parameters.Minimum,
                    parameters.Maximum);
                break;
            default:
                result = 0;
                break;
        }
        return precision.HasValue
            ? Math.Round(result, precision.Value)
            : result;
    }

    /// <summary>
    /// Gets a random boolean value.
    /// </summary>
    /// <returns>A random boolean value.</returns>
    public bool NextBool() => _generator.NextBool();

    /// <summary>
    /// Gets a random boolean value with a given probability of selecting <see
    /// langword="true"/>.
    /// </summary>
    /// <param name="probabilityOfTrue">
    /// <para>
    /// The probability that the result will be <see langword="true"/>. [0, 1]
    /// </para>
    /// <para>
    /// Values less than 0 will be treated as 0, and values greater than 1 will be treated as 1.
    /// </para>
    /// </param>
    /// <returns>A random boolean value.</returns>
    public bool NextBool(double probabilityOfTrue) => _generator.NextDouble() <= probabilityOfTrue;

    /// <summary>
    /// Fills the elements of the given <paramref name="buffer" /> with random <see cref="byte" />
    /// values.
    /// </summary>
    /// <param name="buffer">An array of bytes whose values will be randomized.</param>
    /// <exception cref="ArgumentNullException"><paramref name="buffer" /> is null.</exception>
    public void NextBytes(byte[] buffer) => _generator.NextBytes(buffer);

    /// <summary>
    /// Fills the elements of the given <see cref="Span{T}"/> with random <see cref="byte" />
    /// values.
    /// </summary>
    /// <param name="buffer">A <see cref="Span{T}"/> of bytes whose values will be
    /// randomized.</param>
    public void NextBytes(Span<byte> buffer) => _generator.NextBytes(buffer);

    /// <summary>
    /// Gets a random, nonnegative floating point number less than 1.
    /// </summary>
    /// <returns>A random, nonnegative floating point number less than 1.</returns>
    public decimal NextDecimal() => _generator.NextDecimal();

    /// <summary>
    /// Gets a random floating point number between zero and <paramref name="maxValue"/>.
    /// </summary>
    /// <param name="maxValue">
    /// <para>
    /// The exclusive maximum bound of the random number to be generated.
    /// </para>
    /// <para>
    /// If this value is negative, it is considered an exclusive minimum bound instead (and zero
    /// becomes the inclusive maximum bound).
    /// </para>
    /// <para>
    /// If the value is positive or negative infinity, it will always be returned as the result.
    /// </para>
    /// </param>
    /// <returns>A random, nonnegative floating point number less than <paramref
    /// name="maxValue"/>.</returns>
    public decimal NextDecimal(decimal maxValue) => _generator.NextDecimal(maxValue);

    /// <summary>
    /// Gets a random floating point number greater than or equal to <paramref name="minValue"/>
    /// and less than or equal to <paramref name="maxValue"/>.
    /// </summary>
    /// <param name="minValue">
    /// The inclusive minimum bound of the random number to be generated.
    /// </param>
    /// <param name="maxValue">
    /// The exclusive maximum bound of the random number to be generated.
    /// </param>
    /// <returns>A random floating point number greater than or equal to <paramref
    /// name="minValue"/> and less than <paramref name="maxValue"/>.</returns>
    /// <remarks>
    /// If <paramref name="minValue"/> is greater than <paramref name="maxValue"/>, the result
    /// is determined by <see cref="RandomizeOptions.InvalidIntegralRangeResult"/>.
    /// </remarks>
    public decimal NextDecimal(decimal minValue, decimal maxValue) => _generator.NextDecimal(minValue, maxValue);

    /// <summary>
    /// Gets a random, nonnegative floating point number less than 1.
    /// </summary>
    /// <returns>A random, nonnegative floating point number less than 1.</returns>
    public double NextDouble() => _generator.NextDouble();

    /// <summary>
    /// Gets a random floating point number between zero and <paramref name="maxValue"/>.
    /// </summary>
    /// <param name="maxValue">
    /// <para>
    /// The exclusive maximum bound of the random number to be generated.
    /// </para>
    /// <para>
    /// If this value is negative, it is considered an exclusive minimum bound instead (and zero
    /// becomes the inclusive maximum bound).
    /// </para>
    /// <para>
    /// If the value is <see cref="double.NaN"/> the result will also be <see
    /// cref="double.NaN"/>.
    /// </para>
    /// <para>
    /// If the value is positive or negative infinity, it will always be returned as the result.
    /// </para>
    /// </param>
    /// <returns>A random, nonnegative floating point number less than <paramref
    /// name="maxValue"/>.</returns>
    public double NextDouble(double maxValue) => _generator.NextDouble(maxValue);

    /// <summary>
    /// Gets a random floating point number greater than or equal to <paramref name="minValue"/>
    /// and less than or equal to <paramref name="maxValue"/>.
    /// </summary>
    /// <param name="minValue">
    /// <para>
    /// The inclusive minimum bound of the random number to be generated.
    /// </para>
    /// <para>
    /// If the value is <see cref="double.NaN"/> the result will also be <see
    /// cref="double.NaN"/>.
    /// </para>
    /// <para>
    /// If the value is positive or negative infinity, it will always be returned as the result
    /// unless <paramref name="maxValue"/> is the opposing infinity (in which case either
    /// positive or negative infinity will be returned randomly).
    /// </para>
    /// </param>
    /// <param name="maxValue">
    /// <para>
    /// The exclusive maximum bound of the random number to be generated.
    /// </para>
    /// <para>
    /// If the value is <see cref="double.NaN"/> the result will also be <see
    /// cref="double.NaN"/>.
    /// </para>
    /// <para>
    /// If the value is positive or negative infinity, it will always be returned as the result
    /// unless <paramref name="minValue"/> is the opposing infinity (in which case either
    /// positive or negative infinity will be returned randomly).
    /// </para>
    /// </param>
    /// <returns>A random, nonnegative integer greater than or equal to <paramref
    /// name="minValue"/> and less than <paramref name="maxValue"/>.</returns>
    /// <remarks>
    /// If <paramref name="minValue"/> is greater than <paramref name="maxValue"/>, the result
    /// is determined by <see cref="RandomizeOptions.InvalidFloatingRangeResult"/>.
    /// </remarks>
    public double NextDouble(double minValue, double maxValue) => _generator.NextDouble(minValue, maxValue);

    /// <summary>
    /// Gets a random, nonnegative integer less than or equal to <see cref="int.MaxValue" />.
    /// </summary>
    /// <returns>A random, nonnegative integer less than or equal to <see cref="int.MaxValue"
    /// />.</returns>
    public int NextInclusive() => _generator.NextInclusive();

    /// <summary>
    /// Gets a random integer greater than or equal to zero and less than or equal to <paramref
    /// name="maxValue" />.
    /// </summary>
    /// <param name="maxValue">
    /// <para>
    /// The inclusive maximum bound of the random number to be generated.
    /// </para>
    /// <para>
    /// If this value is negative, it is considered an exclusive minimum bound instead (and zero
    /// becomes the inclusive maximum bound).
    /// </para>
    /// </param>
    /// <returns>A random, nonnegative integer greater than or equal to zero and less than or
    /// equal to <paramref name="maxValue" />.</returns>
    public int NextInclusive(int maxValue) => _generator.NextInclusive(maxValue);

    /// <summary>
    /// Gets a random integer greater than or equal to <paramref name="minValue" />
    /// and less than or equal to <paramref name="maxValue" />.
    /// </summary>
    /// <param name="minValue">The inclusive minimum bound of the random number to be
    /// generated.</param>
    /// <param name="maxValue">The inclusive maximum bound of the random number to be
    /// generated.</param>
    /// <returns>A random, nonnegative integer greater than or equal to <paramref
    /// name="minValue" /> and less than or equal to <paramref name="maxValue" />.</returns>
    /// <remarks>
    /// If <paramref name="minValue" /> is greater than <paramref name="maxValue" />, the result
    /// is determined by <see cref="RandomizeOptions.InvalidIntegralRangeResult" />.
    /// </remarks>
    public int NextInclusive(int minValue, int maxValue) => _generator.NextInclusive(minValue, maxValue);

    /// <summary>
    /// <para>
    /// Gets a random index to the given <see cref="IList{T}"/>.
    /// </para>
    /// <para>
    /// Each index has an equal chance of being selected. To select an index according to a
    /// weighted distribution, use <see cref="NextIndex{T}(IList{T}, Func{T, double})"/>. Note
    /// that if you are generating multiple results, it is more efficient to instead call <see
    /// cref="CategoricalDistributionSamples(int, ICollection{double})"/> with the collection of
    /// weights as the parameter.
    /// </para>
    /// <para>
    /// To select an element rather than an index, use <see cref="Next{T}(IList{T})"/>.
    /// </para>
    /// </summary>
    /// <typeparam name="T">The type of elements in the list.</typeparam>
    /// <param name="list">An <see cref="IList{T}"/>.</param>
    /// <returns>
    /// A randomly-selected index to <paramref name="list"/>, or -1 if <paramref name="list"/>
    /// is <see langword="null"/> or contains no elements.
    /// </returns>
    public int NextIndex<T>(IList<T>? list) => (list?.Count ?? 0) == 0 ? -1 : Next(list!.Count);

    /// <summary>
    /// <para>
    /// Gets a random index to the given <see cref="IList{T}"/>, where each index has a weighted
    /// chance of selected, given by the function provided.
    /// </para>
    /// <para>
    /// To select an index at random from an unweighted collection, use <see
    /// cref="NextIndex{T}(IList{T})"/>.
    /// </para>
    /// <para>
    /// Note that if you are generating multiple results, it is more efficient to instead call
    /// <see cref="CategoricalDistributionSamples(int, ICollection{double})"/> with the
    /// collection of weights as the parameter.
    /// </para>
    /// <para>
    /// To select an element rather than an index, use <see cref="Next{T}(IList{T}, Func{T,
    /// double})"/>.
    /// </para>
    /// </summary>
    /// <typeparam name="T">The type of elements in the list.</typeparam>
    /// <param name="list">An <see cref="IList{T}"/>.</param>
    /// <param name="weightFunction">A function which provides a weight, given an element in the
    /// <paramref name="list"/>.</param>
    /// <returns>
    /// A randomly-selected index to <paramref name="list"/>, or -1 if <paramref name="list"/>
    /// is <see langword="null"/> or contains no elements.
    /// </returns>
    public int NextIndex<T>(IList<T>? list, Func<T, double> weightFunction)
        => (list?.Count ?? 0) == 0
            ? -1
            : CategoricalDistributionSample(list!.Select(weightFunction).ToList());

    /// <summary>
    /// Gets a random, normalized quaternion whose components are floating-point numbers.
    /// </summary>
    /// <returns>A random, normalized quaternion whose components are floating-point numbers.</returns>
    /// <remarks>
    /// Each component is selected randomly as a value between 0 and 1, then the result is
    /// normalized. This may cause some form of quasi-Gaussian distribution of results, as the
    /// result is a composite of four independently determined variables, but the
    /// interdependence between components of a quaternion is loose enough that this effect is
    /// considered to be inconsequential.
    /// </remarks>
    public Quaternion<T> NextQuaternion<T>() where T : IFloatingPointIeee754<T>
        => Quaternion<T>.Normalize(new Quaternion<T>(Next<T>(), Next<T>(), Next<T>(), Next<T>()));

    /// <summary>
    /// Gets a random, normalized quaternion whose components are <see cref="double"/> values.
    /// </summary>
    /// <returns>A random, normalized quaternion whose components are <see cref="double"/>
    /// values.</returns>
    /// <remarks>
    /// Each component is selected randomly as a value between 0 and 1, then the result is
    /// normalized. This may cause some form of quasi-Gaussian distribution of results, as the
    /// result is a composite of four independently determined variables, but the
    /// interdependence between components of a quaternion is loose enough that this effect is
    /// considered to be inconsequential.
    /// </remarks>
    public Quaternion<double> NextQuaternionDouble()
        => Quaternion<double>.Normalize(new Quaternion<double>(NextDouble(), NextDouble(), NextDouble(), NextDouble()));

    /// <summary>
    /// Gets a random, unsigned integer less than <see cref="uint.MaxValue" />.
    /// </summary>
    /// <returns>A random, unsigned integer less than <see cref="uint.MaxValue" />.</returns>
    public uint NextUInt() => _generator.NextUInt();

    /// <summary>
    /// Gets a random, unsigned integer less than <paramref name="maxValue" />.
    /// </summary>
    /// <param name="maxValue">The exclusive maximum bound of the random number to be
    /// generated.</param>
    /// <returns>A random, unsigned integer less than <paramref name="maxValue" />.</returns>
    public uint NextUInt(uint maxValue) => _generator.NextUInt(maxValue);

    /// <summary>
    /// Gets a random, unsigned integer greater than or equal to <paramref name="minValue" />
    /// and less than <paramref name="maxValue" />.
    /// </summary>
    /// <param name="minValue">The inclusive minimum bound of the random number to be
    /// generated.</param>
    /// <param name="maxValue">The exclusive maximum bound of the random number to be
    /// generated.</param>
    /// <returns>A random integer greater than or equal to <paramref name="minValue" /> and less
    /// than <paramref name="maxValue" />.</returns>
    /// <remarks>
    /// If <paramref name="minValue" /> is greater than <paramref name="maxValue" />, the result
    /// is determined by <see cref="RandomizeOptions.InvalidIntegralRangeResult" />.
    /// </remarks>
    public uint NextUInt(uint minValue, uint maxValue) => _generator.NextUInt(minValue, maxValue);

    /// <summary>
    /// Gets a random, unsigned integer less than or equal to <see cref="uint.MaxValue" />.
    /// </summary>
    /// <returns>A random, unsigned integer less than or equal to <see cref="uint.MaxValue"
    /// />.</returns>
    public uint NextUIntInclusive() => _generator.NextUIntInclusive();

    /// <summary>
    /// Gets a random integer greater than or equal to zero and less than or equal to <paramref
    /// name="maxValue" />.
    /// </summary>
    /// <param name="maxValue">
    /// <para>
    /// The inclusive maximum bound of the random number to be generated.
    /// </para>
    /// </param>
    /// <returns>A random, nonnegative integer greater than or equal to zero and less than or
    /// equal to <paramref name="maxValue" />.</returns>
    public uint NextUIntInclusive(uint maxValue) => _generator.NextUIntInclusive(maxValue);

    /// <summary>
    /// Gets a random, unsigned integer greater than or equal to <paramref name="minValue" />
    /// and less than or equal to <paramref name="maxValue" />.
    /// </summary>
    /// <param name="minValue">The inclusive minimum bound of the random number to be
    /// generated.</param>
    /// <param name="maxValue">The inclusive maximum bound of the random number to be
    /// generated.</param>
    /// <returns>A random integer greater than or equal to <paramref name="minValue" /> and less
    /// than or equal to <paramref name="maxValue" />.</returns>
    /// <remarks>
    /// If <paramref name="minValue" /> is greater than <paramref name="maxValue" />, the result
    /// is determined by <see cref="RandomizeOptions.InvalidIntegralRangeResult" />.
    /// </remarks>
    public uint NextUIntInclusive(uint minValue, uint maxValue) => _generator.NextUIntInclusive(minValue, maxValue);

    /// <summary>
    /// Gets a randomly oriented vector whose length is between 0 and <paramref
    /// name="maxLength"/>, and whose components are floating-point numbers.
    /// </summary>
    /// <param name="maxLength">
    /// <para>
    /// The exclusive upper bound of the length of the vector to be generated.
    /// </para>
    /// <para>
    /// Values below zero will be treated as zero.
    /// </para>
    /// <para>
    /// <see cref="IFloatingPointIeee754{TSelf}.PositiveInfinity"/> will always result in an
    /// infinite-length vector.
    /// </para>
    /// </param>
    /// <returns>
    /// A randomly oriented vector whose length is between 0 and <paramref
    /// name="maxLength"/>, and whose components are floating-point numbers.
    /// </returns>
    /// <remarks>
    /// A random rotation is generated with <see cref="NextQuaternion{T}()"/>, then the
    /// vector is scaled randomly according to <paramref name="maxLength"/>, to avoid
    /// unintentionally generating lengths in a quasi-Gaussian distribution, as would occur if
    /// the vector components were generated independently.
    /// </remarks>
    public Vector3<T> NextVector3<T>(T maxLength) where T : IFloatingPointIeee754<T>
        => Vector3<T>.Transform(Vector3<T>.UnitX, NextQuaternion<T>()) * Next(maxLength);

    /// <summary>
    /// Gets a randomly oriented vector whose length is between <paramref name="minLength"/> and
    /// <paramref name="maxLength"/>, and whose components are floating-point numbers.
    /// </summary>
    /// <param name="minLength">The inclusive lower bound of the length of the vector to be
    /// generated.</param>
    /// <param name="maxLength">
    /// The exclusive upper bound of the length of the vector to be generated.
    /// </param>
    /// <returns>
    /// A randomly oriented vector whose length is between <paramref name="minLength"/>
    /// and <paramref name="maxLength"/>, and whose components are floating-point numbers.
    /// </returns>
    /// <remarks>
    /// <para>
    /// A random rotation is generated with <see cref="NextQuaternion{T}()"/>, then the
    /// vector is scaled randomly according to <paramref name="minLength"/> and <paramref
    /// name="maxLength"/>, to avoid unintentionally generating lengths in a quasi-Gaussian
    /// distribution, as would occur if the vector components were generated independently.
    /// </para>
    /// <para>
    /// If <paramref name="minLength"/> is greater than <paramref name="maxLength"/>, the result
    /// is determined by <see cref="RandomizeOptions.InvalidIntegralRangeResult"/>.
    /// </para>
    /// </remarks>
    public Vector3<T> NextVector3<T>(T minLength, T maxLength) where T : IFloatingPointIeee754<T>
        => Vector3<T>.Transform(Vector3<T>.UnitX, NextQuaternion<T>()) * Next(minLength, maxLength);

    /// <summary>
    /// Gets a randomly oriented vector whose length is between 0 and <paramref
    /// name="maxLength"/>, and whose components are <see cref="double"/> values.
    /// </summary>
    /// <param name="maxLength">
    /// <para>
    /// The exclusive upper bound of the length of the vector to be generated.
    /// </para>
    /// <para>
    /// Values below zero will be treated as zero.
    /// </para>
    /// <para>
    /// <see cref="double.PositiveInfinity"/> will always result in an infinite-length vector.
    /// </para>
    /// </param>
    /// <returns>A randomly oriented vector whose length is between 0 and <paramref
    /// name="maxLength"/>, and whose components are <see cref="double"/> values.</returns>
    /// <remarks>
    /// A random rotation is generated with <see cref="NextQuaternionDouble()"/>, then the
    /// vector is scaled randomly according to <paramref name="maxLength"/>, to avoid
    /// unintentionally generating lengths in a quasi-Gaussian distribution, as would occur if
    /// the vector components were generated independently.
    /// </remarks>
    public Vector3<double> NextVector3Double(double maxLength) => Vector3<double>.Transform(
        Vector3<double>.UnitX,
        NextQuaternionDouble()) * NextDouble(maxLength);

    /// <summary>
    /// Gets a randomly oriented vector whose length is between <paramref name="minLength"/> and
    /// <paramref name="maxLength"/>, and whose components are <see cref="double"/> values.
    /// </summary>
    /// <param name="minLength">The inclusive lower bound of the length of the vector to be
    /// generated.</param>
    /// <param name="maxLength">
    /// The exclusive upper bound of the length of the vector to be generated.
    /// </param>
    /// <returns>A randomly oriented vector whose length is between <paramref name="minLength"/>
    /// and <paramref name="maxLength"/>, and whose components are <see cref="double"/>
    /// values.</returns>
    /// <remarks>
    /// <para>
    /// A random rotation is generated with <see cref="NextQuaternionDouble()"/>, then the
    /// vector is scaled randomly according to <paramref name="minLength"/> and <paramref
    /// name="maxLength"/>, to avoid unintentionally generating lengths in a quasi-Gaussian
    /// distribution, as would occur if the vector components were generated independently.
    /// </para>
    /// <para>
    /// If <paramref name="minLength"/> is greater than <paramref name="maxLength"/>, the result
    /// is determined by <see cref="RandomizeOptions.InvalidIntegralRangeResult"/>.
    /// </para>
    /// </remarks>
    public Vector3<double> NextVector3Double(double minLength, double maxLength) => Vector3<double>.Transform(
        Vector3<double>.UnitX,
        NextQuaternionDouble()) * NextDouble(minLength, maxLength);

    /// <summary>
    /// <para>
    /// Gets a sample pseudo-random value from a normal distribution.
    /// </para>
    /// <para>
    /// When generating multiple values, use <see cref="NormalDistributionSamples(int, double,
    /// double, double?, double?)"/>.
    /// </para>
    /// </summary>
    /// <param name="mu">
    /// <para>
    /// The location (mean) of the distribution.
    /// </para>
    /// <para>
    /// If <see cref="double.NaN"/>, all results will be <see cref="double.NaN"/>.
    /// </para>
    /// </param>
    /// <param name="sigma">
    /// <para>
    /// The standard deviation of the distribution. (0, ∞)
    /// </para>
    /// <para>
    /// If <see cref="double.NaN"/>, all results will be <see cref="double.NaN"/>.
    /// </para>
    /// <para>
    /// If less than or equal to zero, will be set to the smallest value recognized as greater
    /// than zero in this library (<see cref="NumberValues.NearlyZeroDouble"/>).
    /// </para>
    /// </param>
    /// <param name="minimum">
    /// <para>
    /// A minimum value. Does not affect the shape of the function, but results less than this
    /// value will not be generated.
    /// </para>
    /// </param>
    /// <param name="maximum">
    /// <para>
    /// A maximum value. Does not affect the shape of the function, but results greater than
    /// this value will not be generated.
    /// </para>
    /// </param>
    /// <returns>A sample value from a normal distribution.</returns>
    /// <remarks>
    /// If <paramref name="minimum"/> and <paramref name="maximum"/> are both non-<see
    /// langword="null"/> and <paramref name="minimum" /> is greater than <paramref
    /// name="maximum" />, the result is determined by <see
    /// cref="RandomizeOptions.InvalidFloatingRangeResult" />.
    /// </remarks>
    public double NormalDistributionSample(
        double mu = 0,
        double sigma = 1,
        double? minimum = null,
        double? maximum = null)
        => NormalDistribution.Samples(_generator, 1, mu, sigma, minimum, maximum).First();

    /// <summary>
    /// Enumerates sample pseudo-random values from a normal distribution.
    /// </summary>
    /// <param name="numberOfSamples">
    /// <para>
    /// The number of sample values to generate. This parameter ensures that operations like
    /// <see cref="Enumerable.ToList"/> will not cause an overflow, by preventing an
    /// infinite enumeration. If more than <see cref="int.MaxValue"/> samples are required, this
    /// method can be called again to "refresh" the count.
    /// </para>
    /// <para>
    /// Values less than zero will be treated as zero.
    /// </para>
    /// </param>
    /// <param name="mu">
    /// <para>
    /// The location (mean) of the distribution.
    /// </para>
    /// <para>
    /// If <see cref="double.NaN"/>, all results will be <see cref="double.NaN"/>.
    /// </para>
    /// </param>
    /// <param name="sigma">
    /// <para>
    /// The standard deviation of the distribution. (0, ∞)
    /// </para>
    /// <para>
    /// If <see cref="double.NaN"/>, all results will be <see cref="double.NaN"/>.
    /// </para>
    /// <para>
    /// If less than or equal to zero, will be set to the smallest value recognized as greater
    /// than zero in this library (<see cref="NumberValues.NearlyZeroDouble"/>).
    /// </para>
    /// </param>
    /// <param name="minimum">
    /// <para>
    /// A minimum value. Does not affect the shape of the function, but results less than this
    /// value will not be generated.
    /// </para>
    /// </param>
    /// <param name="maximum">
    /// <para>
    /// A maximum value. Does not affect the shape of the function, but results greater than
    /// this value will not be generated.
    /// </para>
    /// </param>
    /// <returns>An <see cref="IEnumerable{T}"/> of sample values from a normal
    /// distribution.</returns>
    /// <remarks>
    /// If <paramref name="minimum"/> and <paramref name="maximum"/> are both non-<see
    /// langword="null"/> and <paramref name="minimum" /> is greater than <paramref
    /// name="maximum" />, the result is determined by <see
    /// cref="RandomizeOptions.InvalidFloatingRangeResult" />.
    /// </remarks>
    public IEnumerable<double> NormalDistributionSamples(
        int numberOfSamples = 1,
        double mu = 0,
        double sigma = 1,
        double? minimum = null,
        double? maximum = null)
        => NormalDistribution.Samples(_generator, numberOfSamples, mu, sigma, minimum, maximum);

    /// <summary>
    /// <para>
    /// Gets a sample pseudo-random value from the positive half of a normal distribution.
    /// </para>
    /// <para>
    /// When generating multiple values, use <see cref="NormalDistributionSamples(int, double,
    /// double, double?, double?)"/>.
    /// </para>
    /// </summary>
    /// <param name="mu">
    /// <para>
    /// The location (mean) of the distribution.
    /// </para>
    /// <para>
    /// If <see cref="double.NaN"/>, all results will be <see cref="double.NaN"/>.
    /// </para>
    /// </param>
    /// <param name="sigma">
    /// <para>
    /// The standard deviation of the distribution. (0, ∞)
    /// </para>
    /// <para>
    /// If <see cref="double.NaN"/>, all results will be <see cref="double.NaN"/>.
    /// </para>
    /// <para>
    /// If less than or equal to zero, will be set to the smallest value recognized as greater
    /// than zero in this library (<see cref="NumberValues.NearlyZeroDouble"/>).
    /// </para>
    /// </param>
    /// <param name="maximum">
    /// <para>
    /// A maximum value. Does not affect the shape of the function, but results greater than
    /// this value will not be generated.
    /// </para>
    /// </param>
    /// <returns>A sample value from the positive half of a normal distribution.</returns>
    public double PositiveNormalDistributionSample(
        double mu = 0,
        double sigma = 1,
        double? maximum = null)
        => PositiveNormalDistribution.Samples(_generator, 1, mu, sigma, maximum).First();

    /// <summary>
    /// Enumerates sample pseudo-random values from the positive half of a normal distribution.
    /// </summary>
    /// <param name="numberOfSamples">
    /// <para>
    /// The number of sample values to generate. This parameter ensures that operations like
    /// <see cref="Enumerable.ToList"/> will not cause an overflow, by preventing an infinite
    /// enumeration. If more than <see cref="int.MaxValue"/> samples are required, this method
    /// can be called again to "refresh" the count.
    /// </para>
    /// <para>
    /// Values less than zero will be treated as zero.
    /// </para>
    /// </param>
    /// <param name="mu">
    /// <para>
    /// The location (mean) of the distribution.
    /// </para>
    /// <para>
    /// If <see cref="double.NaN"/>, all results will be <see cref="double.NaN"/>.
    /// </para>
    /// </param>
    /// <param name="sigma">
    /// <para>
    /// The standard deviation of the distribution. (0, ∞)
    /// </para>
    /// <para>
    /// If <see cref="double.NaN"/>, all results will be <see cref="double.NaN"/>.
    /// </para>
    /// <para>
    /// If less than or equal to zero, will be set to the smallest value recognized as greater
    /// than zero in this library (<see cref="NumberValues.NearlyZeroDouble"/>).
    /// </para>
    /// </param>
    /// <param name="maximum">
    /// <para>
    /// A maximum value. Does not affect the shape of the function, but results greater than
    /// this value will not be generated.
    /// </para>
    /// </param>
    /// <returns>An <see cref="IEnumerable{T}"/> of sample values from the positive half of a
    /// normal distribution.</returns>
    public IEnumerable<double> PositiveNormalDistributionSamples(
        int numberOfSamples = 1,
        double mu = 0,
        double sigma = 1,
        double? maximum = null)
        => PositiveNormalDistribution.Samples(_generator, numberOfSamples, mu, sigma, maximum);

    /// <summary>
    /// <para>
    /// Resets the generator, without changing its current seed.
    /// </para>
    /// <para>
    /// An identical series of values will be produced each time this is called.
    /// </para>
    /// </summary>
    public void Reset() => _generator.Reset();

    /// <summary>
    /// <para>
    /// Resets the generator with the provided seed.
    /// </para>
    /// <para>
    /// An identical series of values will be produced each time this is called with the same
    /// seed.
    /// </para>
    /// </summary>
    /// <param name="seed">The seed value.</param>
    public void Reset(uint seed) => _generator.Reset(seed);
}
