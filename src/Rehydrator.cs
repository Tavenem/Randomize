namespace Tavenem.Randomize;

/// <summary>
/// <para>
/// The Rehydrator class allows a deterministic set of random values to be recreated from the
/// same seed, even if those values are requested out of order.
/// </para>
/// <para>
/// The expectation is that this class will be instantiated by a class which generates part of
/// its state with randomized values. Individual random values are retrieved by index, and the
/// seed is stored along with any other persistent object data. Even if the order of operations
/// in the class changes after a revision, the same values can be guaranteed, provided the same
/// seed and indexes are used.
/// </para>
/// </summary>
/// <remarks>
/// <para>
/// Only <see cref="ulong.MaxValue"/> values may be generated by a Rehydrator instance.
/// </para>
/// </remarks>
public class Rehydrator
{
    private readonly Randomizer _randomizer;

    private ulong _index;

    /// <summary>
    /// This instance's seed.
    /// </summary>
    public uint Seed { get; }

    /// <summary>
    /// Initializes a new instance of <see cref="Rehydrator"/> with a random seed.
    /// </summary>
    public Rehydrator() : this(Randomizer.Instance.NextUIntInclusive()) { }

    /// <summary>
    /// Initializes a new instance of <see cref="Rehydrator"/> with a given seed.
    /// </summary>
    public Rehydrator(uint seed)
    {
        Seed = seed;
        _randomizer = new Randomizer(seed);
    }

    /// <summary>
    /// <para>
    /// Gets a sample pseudo-random value from a binomial distribution.
    /// </para>
    /// <para>
    /// When generating multiple values, use <see cref="BinomialDistributionSamples(ulong, int,
    /// uint, double)"/>.
    /// </para>
    /// <para>
    /// If a single trial is generated (the default), gives the Bernoulli distribution.
    /// </para>
    /// </summary>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <param name="n">
    /// <para>
    /// The sample size (number of trials). [0, <see cref="uint.MaxValue"/>]
    /// </para>
    /// <para>
    /// The default of 1 trial gives the Bernoulli distribution.
    /// </para>
    /// </param>
    /// <param name="p">
    /// <para>
    /// The normalized probability of an individual success. [0, 1]
    /// </para>
    /// <para>
    /// This value will be truncated to a valid value if it exceeds the allowable bounds.
    /// </para>
    /// </param>
    /// <returns>A sample pseudo-random value from a binomial distribution.</returns>
    public uint BinomialDistributionSample(ulong index, uint n = 1, double p = 0.5)
        => GetRandomizer(index).BinomialDistributionSample(n, p);

    /// <summary>
    /// <para>
    /// Enumerates sample pseudo-random values from a binomial distribution.
    /// </para>
    /// <para>
    /// If a single trial is generated (the default), gives the Bernoulli distribution.
    /// </para>
    /// </summary>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <param name="numberOfSamples">
    /// <para>
    /// The number of sample values to generate. This parameter ensures that operations like
    /// <see cref="Enumerable.ToList"/> will not cause an overflow, by preventing an
    /// infinite enumeration. If more than <see cref="int.MaxValue"/> samples are required, this
    /// method can be called again to "refresh" the count.
    /// </para>
    /// <para>
    /// Values less than zero will be treated as zero.
    /// </para>
    /// </param>
    /// <param name="n">
    /// <para>
    /// The sample size (number of trials). [0, <see cref="uint.MaxValue"/>]
    /// </para>
    /// <para>
    /// The default of 1 trial gives the Bernoulli distribution.
    /// </para>
    /// </param>
    /// <param name="p">
    /// <para>
    /// The normalized probability of an individual success. [0, 1]
    /// </para>
    /// <para>
    /// This value will be truncated to a valid value if it exceeds the allowable bounds.
    /// </para>
    /// </param>
    /// <returns>An <see cref="IEnumerable{T}"/> of sample pseudo-random values from a binomial
    /// distribution.</returns>
    public IEnumerable<uint> BinomialDistributionSamples(ulong index, int numberOfSamples = 1, uint n = 1, double p = 0.5)
        => GetRandomizer(index).BinomialDistributionSamples(numberOfSamples, n, p);

    /// <summary>
    /// <para>
    /// Gets a sample pseudo-random value from a categorical (discrete) distribution.
    /// </para>
    /// <para>
    /// When generating multiple values, use <see cref="CategoricalDistributionSamples(ulong,
    /// int, int)"/>.
    /// </para>
    /// </summary>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <param name="k">
    /// <para>
    /// The number of equal-weight categories. (0, <see cref="int.MaxValue"/>].
    /// </para>
    /// <para>
    /// A value less than or equal to zero will be treated as a 1.
    /// </para>
    /// </param>
    /// <returns>A sample value from a categorical (discrete) distribution.</returns>
    public int CategoricalDistributionSample(ulong index, int k)
        => GetRandomizer(index).CategoricalDistributionSample(k);

    /// <summary>
    /// <para>
    /// Gets a sample pseudo-random value from a categorical (discrete) distribution.
    /// </para>
    /// <para>
    /// When generating multiple values, use <see cref="CategoricalDistributionSamples(ulong,
    /// int, ICollection{double})"/>.
    /// </para>
    /// </summary>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <param name="weights">
    /// <para>
    /// The normalized probability vector of the categorical distribution.
    /// </para>
    /// <para>
    /// Values do not need to be pre-normalized. They will be normalized if necessary.
    /// </para>
    /// <para>
    /// Any weights which are negative are treated as 0.
    /// </para>
    /// <para>
    /// If <see langword="null"/> or empty, a default set of 3 equal weights will be used.
    /// </para>
    /// </param>
    /// <returns>A sample value from a categorical (discrete) distribution.</returns>
    /// <exception cref="ArgumentException">
    /// The <paramref name="weights"/> collection sums to zero.
    /// </exception>
    public int CategoricalDistributionSample(ulong index, ICollection<double>? weights = null)
        => GetRandomizer(index).CategoricalDistributionSample(weights);

    /// <summary>
    /// Enumerates sample pseudo-random values from a categorical (discrete) distribution.
    /// </summary>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <param name="k">
    /// <para>
    /// The number of equal-weight categories. (0, <see cref="int.MaxValue"/>].
    /// </para>
    /// <para>
    /// A value less than or equal to zero will be treated as a 1.
    /// </para>
    /// </param>
    /// <param name="numberOfSamples">
    /// <para>
    /// The number of sample values to generate. This parameter ensures that operations like
    /// <see cref="Enumerable.ToList"/> will not cause an overflow, by preventing an
    /// infinite enumeration. If more than <see cref="int.MaxValue"/> samples are required, this
    /// method can be called again to "refresh" the count.
    /// </para>
    /// <para>
    /// Values less than zero will be treated as zero.
    /// </para>
    /// </param>
    /// <returns>An <see cref="IEnumerable{T}"/> of sample values from a categorical (discrete)
    /// distribution.</returns>
    public IEnumerable<int> CategoricalDistributionSamples(ulong index, int k, int numberOfSamples = 1)
        => GetRandomizer(index).CategoricalDistributionSamples(k, numberOfSamples);

    /// <summary>
    /// Enumerates sample pseudo-random values from a categorical (discrete) distribution.
    /// </summary>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <param name="numberOfSamples">
    /// <para>
    /// The number of sample values to generate. This parameter ensures that operations like
    /// <see cref="Enumerable.ToList"/> will not cause an overflow, by preventing an
    /// infinite enumeration. If more than <see cref="int.MaxValue"/> samples are required, this
    /// method can be called again to "refresh" the count.
    /// </para>
    /// <para>
    /// Values less than zero will be treated as zero.
    /// </para>
    /// </param>
    /// <param name="weights">
    /// <para>
    /// The normalized probability vector of the categorical distribution.
    /// </para>
    /// <para>
    /// Values do not need to be pre-normalized. They will be normalized if necessary.
    /// </para>
    /// <para>
    /// Any weights which are negative are treated as 0.
    /// </para>
    /// <para>
    /// If <see langword="null"/> or empty, a default set of 3 equal weights will be used.
    /// </para>
    /// </param>
    /// <returns>An <see cref="IEnumerable{T}"/> of sample values from a categorical (discrete)
    /// distribution.</returns>
    /// <exception cref="ArgumentException">
    /// The <paramref name="weights"/> collection sums to zero.
    /// </exception>
    public IEnumerable<int> CategoricalDistributionSamples(
        ulong index,
        int numberOfSamples = 1,
        ICollection<double>? weights = null)
        => GetRandomizer(index).CategoricalDistributionSamples(numberOfSamples, weights);

    /// <summary>
    /// <para>
    /// Gets a sample pseudo-random value from an exponential distribution.
    /// </para>
    /// <para>
    /// When generating multiple values, use <see cref="ExponentialDistributionSamples(ulong,
    /// int, double, double?)"/>.
    /// </para>
    /// </summary>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <param name="lambda">
    /// <para>
    /// The parameter of the distribution (rate parameter). (0, ∞)
    /// </para>
    /// <para>
    /// If <see cref="double.NaN"/>, all results will be <see cref="double.NaN"/>.
    /// </para>
    /// <para>
    /// If less than or equal to zero, will be set to the smallest value recognized as greater
    /// than zero in this library (<see cref="NumberValues.NearlyZeroDouble"/>).
    /// </para>
    /// </param>
    /// <param name="maximum">
    /// <para>
    /// A maximum value. Does not affect the shape of the function, but results greater than
    /// this value will not be generated. [0, ∞)
    /// </para>
    /// <para>
    /// Values less than 0 are treated as 0.
    /// </para>
    /// </param>
    /// <returns>A sample value from an exponential distribution.</returns>
    public double ExponentialDistributionSample(ulong index, double lambda = 1, double? maximum = null)
        => GetRandomizer(index).ExponentialDistributionSample(lambda, maximum);

    /// <summary>
    /// Enumerates sample pseudo-random values from an exponential distribution.
    /// </summary>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <param name="numberOfSamples">
    /// <para>
    /// The number of sample values to generate. This parameter ensures that operations like
    /// <see cref="Enumerable.ToList"/> will not cause an overflow, by preventing an
    /// infinite enumeration. If more than <see cref="int.MaxValue"/> samples are required, this
    /// method can be called again to "refresh" the count.
    /// </para>
    /// <para>
    /// Values less than zero will be treated as zero.
    /// </para>
    /// </param>
    /// <param name="lambda">
    /// <para>
    /// The parameter of the distribution (rate parameter). (0, ∞)
    /// </para>
    /// <para>
    /// If <see cref="double.NaN"/>, all results will be <see cref="double.NaN"/>.
    /// </para>
    /// <para>
    /// If less than or equal to zero, will be set to the smallest value recognized as greater
    /// than zero in this library (<see cref="NumberValues.NearlyZeroDouble"/>).
    /// </para>
    /// </param>
    /// <param name="maximum">
    /// <para>
    /// A maximum value. Does not affect the shape of the function, but results greater than
    /// this value will not be generated. [0, ∞)
    /// </para>
    /// <para>
    /// Values less than 0 are treated as 0.
    /// </para>
    /// </param>
    /// <returns>An <see cref="IEnumerable{T}"/> of sample values from an exponential
    /// distribution.</returns>
    public IEnumerable<double> ExponentialDistributionSamples(
        ulong index,
        int numberOfSamples = 1,
        double lambda = 1,
        double? maximum = null)
        => GetRandomizer(index).ExponentialDistributionSamples(numberOfSamples, lambda, maximum);

    /// <summary>
    /// <para>
    /// Gets a sample pseudo-random value from a logistic distribution.
    /// </para>
    /// <para>
    /// When generating multiple values, use <see cref="LogisticDistributionSamples(ulong, int,
    /// double,
    /// double, double?, double?)"/>.
    /// </para>
    /// </summary>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <param name="mu">
    /// <para>
    /// The location (mean) of the distribution.
    /// </para>
    /// <para>
    /// If <see cref="double.NaN"/>, all results will be <see cref="double.NaN"/>.
    /// </para>
    /// </param>
    /// <param name="sigma">
    /// <para>
    /// The scale of the distribution. (0, ∞)
    /// </para>
    /// <para>
    /// If <see cref="double.NaN"/>, all results will be <see cref="double.NaN"/>.
    /// </para>
    /// <para>
    /// If less than or equal to zero, will be set to the smallest value recognized as greater
    /// than zero in this library (<see cref="NumberValues.NearlyZeroDouble"/>).
    /// </para>
    /// </param>
    /// <param name="minimum">
    /// <para>
    /// A minimum value. Does not affect the shape of the function, but results less than this
    /// value will not be generated.
    /// </para>
    /// </param>
    /// <param name="maximum">
    /// <para>
    /// A maximum value. Does not affect the shape of the function, but results greater than
    /// this value will not be generated.
    /// </para>
    /// </param>
    /// <returns>A sample value from a logistic distribution.</returns>
    /// <remarks>
    /// If <paramref name="minimum"/> and <paramref name="maximum"/> are both non-<see
    /// langword="null"/> and <paramref name="minimum" /> is greater than <paramref
    /// name="maximum" />, the result is determined by <see
    /// cref="RandomizeOptions.InvalidFloatingRangeResult" />.
    /// </remarks>
    public double LogisticDistributionSample(
        ulong index,
        double mu = 0,
        double sigma = 1,
        double? minimum = null,
        double? maximum = null)
        => GetRandomizer(index).LogisticDistributionSample(mu, sigma, minimum, maximum);

    /// <summary>
    /// Enumerates sample pseudo-random values from a logistic distribution.
    /// </summary>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <param name="numberOfSamples">
    /// <para>
    /// The number of sample values to generate. This parameter ensures that operations like
    /// <see cref="Enumerable.ToList"/> will not cause an overflow, by preventing an
    /// infinite enumeration. If more than <see cref="int.MaxValue"/> samples are required, this
    /// method can be called again to "refresh" the count.
    /// </para>
    /// <para>
    /// Values less than zero will be treated as zero.
    /// </para>
    /// </param>
    /// <param name="mu">
    /// <para>
    /// The location (mean) of the distribution.
    /// </para>
    /// <para>
    /// If <see cref="double.NaN"/>, all results will be <see cref="double.NaN"/>.
    /// </para>
    /// </param>
    /// <param name="sigma">
    /// <para>
    /// The scale of the distribution. (0, ∞)
    /// </para>
    /// <para>
    /// If <see cref="double.NaN"/>, all results will be <see cref="double.NaN"/>.
    /// </para>
    /// <para>
    /// If less than or equal to zero, will be set to the smallest value recognized as greater
    /// than zero in this library (<see cref="NumberValues.NearlyZeroDouble"/>).
    /// </para>
    /// </param>
    /// <param name="minimum">
    /// <para>
    /// A minimum value. Does not affect the shape of the function, but results less than this
    /// value will not be generated.
    /// </para>
    /// </param>
    /// <param name="maximum">
    /// <para>
    /// A maximum value. Does not affect the shape of the function, but results greater than
    /// this value will not be generated.
    /// </para>
    /// </param>
    /// <returns>An <see cref="IEnumerable{T}"/> of sample values from a logistic
    /// distribution.</returns>
    /// <remarks>
    /// If <paramref name="minimum"/> and <paramref name="maximum"/> are both non-<see
    /// langword="null"/> and <paramref name="minimum" /> is greater than <paramref
    /// name="maximum" />, the result is determined by <see
    /// cref="RandomizeOptions.InvalidFloatingRangeResult" />.
    /// </remarks>
    public IEnumerable<double> LogisticDistributionSamples(
        ulong index,
        int numberOfSamples = 1,
        double mu = 0,
        double sigma = 1,
        double? minimum = null,
        double? maximum = null)
        => GetRandomizer(index).LogisticDistributionSamples(numberOfSamples, mu, sigma, minimum, maximum);

    /// <summary>
    /// <para>
    /// Gets a sample pseudo-random value from a log-normal distribution.
    /// </para>
    /// <para>
    /// When generating multiple values, use <see cref="LogNormalDistributionSamples(ulong, int,
    /// double, double, double?, double?)"/>.
    /// </para>
    /// </summary>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <param name="mu">
    /// <para>
    /// The location (mean) of the distribution.
    /// </para>
    /// <para>
    /// If <see cref="double.NaN"/>, all results will be <see cref="double.NaN"/>.
    /// </para>
    /// </param>
    /// <param name="sigma">
    /// <para>
    /// The scale of the distribution. (0, ∞)
    /// </para>
    /// <para>
    /// If <see cref="double.NaN"/>, all results will be <see cref="double.NaN"/>.
    /// </para>
    /// <para>
    /// If less than or equal to zero, will be set to the smallest value recognized as greater
    /// than zero in this library (<see cref="NumberValues.NearlyZeroDouble"/>).
    /// </para>
    /// </param>
    /// <param name="minimum">
    /// <para>
    /// A minimum value. Does not affect the shape of the function, but results less than this
    /// value will not be generated.
    /// </para>
    /// </param>
    /// <param name="maximum">
    /// <para>
    /// A maximum value. Does not affect the shape of the function, but results greater than
    /// this value will not be generated.
    /// </para>
    /// </param>
    /// <returns>A sample value from a log-normal distribution.</returns>
    /// <remarks>
    /// If <paramref name="minimum"/> and <paramref name="maximum"/> are both non-<see
    /// langword="null"/> and <paramref name="minimum" /> is greater than <paramref
    /// name="maximum" />, the result is determined by <see
    /// cref="RandomizeOptions.InvalidFloatingRangeResult" />.
    /// </remarks>
    public double LogNormalDistributionSample(
        ulong index,
        double mu = 0,
        double sigma = 1,
        double? minimum = null,
        double? maximum = null)
        => GetRandomizer(index).LogNormalDistributionSample(mu, sigma, minimum, maximum);

    /// <summary>
    /// Enumerates sample pseudo-random values from a log-normal distribution.
    /// </summary>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <param name="numberOfSamples">
    /// <para>
    /// The number of sample values to generate. This parameter ensures that operations like
    /// <see cref="Enumerable.ToList"/> will not cause an overflow, by preventing an
    /// infinite enumeration. If more than <see cref="int.MaxValue"/> samples are required, this
    /// method can be called again to "refresh" the count.
    /// </para>
    /// <para>
    /// Values less than zero will be treated as zero.
    /// </para>
    /// </param>
    /// <param name="mu">
    /// <para>
    /// The location (mean) of the distribution.
    /// </para>
    /// <para>
    /// If <see cref="double.NaN"/>, all results will be <see cref="double.NaN"/>.
    /// </para>
    /// </param>
    /// <param name="sigma">
    /// <para>
    /// The scale of the distribution. (0, ∞)
    /// </para>
    /// <para>
    /// If <see cref="double.NaN"/>, all results will be <see cref="double.NaN"/>.
    /// </para>
    /// <para>
    /// If less than or equal to zero, will be set to the smallest value recognized as greater
    /// than zero in this library (<see cref="NumberValues.NearlyZeroDouble"/>).
    /// </para>
    /// </param>
    /// <param name="minimum">
    /// <para>
    /// A minimum value. Does not affect the shape of the function, but results less than this
    /// value will not be generated.
    /// </para>
    /// </param>
    /// <param name="maximum">
    /// <para>
    /// A maximum value. Does not affect the shape of the function, but results greater than
    /// this value will not be generated.
    /// </para>
    /// </param>
    /// <returns>An <see cref="IEnumerable{T}"/> of sample values from a log-normal
    /// distribution.</returns>
    /// <remarks>
    /// If <paramref name="minimum"/> and <paramref name="maximum"/> are both non-<see
    /// langword="null"/> and <paramref name="minimum" /> is greater than <paramref
    /// name="maximum" />, the result is determined by <see
    /// cref="RandomizeOptions.InvalidFloatingRangeResult" />.
    /// </remarks>
    public IEnumerable<double> LogNormalDistributionSamples(
        ulong index,
        int numberOfSamples = 1,
        double mu = 0,
        double sigma = 1,
        double? minimum = null,
        double? maximum = null)
        => GetRandomizer(index).LogNormalDistributionSamples(numberOfSamples, mu, sigma, minimum, maximum);

    /// <summary>
    /// Gets a random, nonnegative integer less than <see cref="int.MaxValue" />.
    /// </summary>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <returns>A random, nonnegative integer less than <see cref="int.MaxValue" />.</returns>
    public int Next(ulong index) => SetIndex(index).Next();

    /// <summary>
    /// Gets a random, nonnegative integer less than <paramref name="maxValue" />.
    /// </summary>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <param name="maxValue">
    /// <para>
    /// The exclusive maximum bound of the random number to be generated.
    /// </para>
    /// <para>
    /// If this value is negative, it is considered an exclusive minimum bound instead (and zero
    /// becomes the inclusive maximum bound).
    /// </para>
    /// </param>
    /// <returns>A random, nonnegative integer less than <paramref name="maxValue" />.</returns>
    public int Next(ulong index, int maxValue) => SetIndex(index).Next(maxValue);

    /// <summary>
    /// Gets a random integer greater than or equal to <paramref name="minValue" />
    /// and less than <paramref name="maxValue" />.
    /// </summary>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <param name="minValue">The inclusive minimum bound of the random number to be
    /// generated.</param>
    /// <param name="maxValue">The exclusive maximum bound of the random number to be
    /// generated.</param>
    /// <returns>A random integer greater than or equal to <paramref name="minValue" /> and less
    /// than <paramref name="maxValue" />.</returns>
    /// <remarks>
    /// If <paramref name="minValue" /> is greater than <paramref name="maxValue" />, the result
    /// is determined by <see cref="RandomizeOptions.InvalidIntegralRangeResult" />.
    /// </remarks>
    public int Next(ulong index, int minValue, int maxValue) => SetIndex(index).Next(minValue, maxValue);

    /// <summary>
    /// Gets a random, nonnegative floating-point number less than 1.
    /// </summary>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <returns>A random, nonnegative floating-point number less than 1.</returns>
    public T Next<T>(ulong index) where T : IFloatingPoint<T> => SetIndex(index).Next<T>();

    /// <summary>
    /// Gets a random floating-point number between zero and <paramref name="maxValue"/>.
    /// </summary>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <param name="maxValue">
    /// <para>
    /// The exclusive maximum bound of the random number to be generated.
    /// </para>
    /// <para>
    /// If this value is negative, it is considered an exclusive minimum bound instead (and zero
    /// becomes the inclusive maximum bound).
    /// </para>
    /// <para>
    /// If the value satisfies <see cref="INumberBase{TSelf}.IsNaN(TSelf)"/> the result will be the
    /// result of 0/0 (normally <see cref="IFloatingPointIeee754{TSelf}.NaN"/>, but this might
    /// result in an exception if <typeparamref name="T"/> does not implement <see
    /// cref="IFloatingPointIeee754{TSelf}"/>).
    /// </para>
    /// <para>
    /// If the value is positive or negative infinity, it will always be returned as the result.
    /// </para>
    /// </param>
    /// <returns>A random, nonnegative floating-point number less than <paramref
    /// name="maxValue"/>.</returns>
    public T Next<T>(ulong index, T maxValue) where T : IFloatingPoint<T>
        => SetIndex(index).Next<T>(maxValue);

    /// <summary>
    /// Gets a random floating-point number greater than or equal to <paramref name="minValue"/> and
    /// less than or equal to <paramref name="maxValue"/>.
    /// </summary>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <param name="minValue">
    /// <para>
    /// The inclusive minimum bound of the random number to be generated.
    /// </para>
    /// <para>
    /// If the value satisfies <see cref="INumberBase{TSelf}.IsNaN(TSelf)"/> the result will be <see
    /// cref="IFloatingPointIeee754{TSelf}.NaN"/>.
    /// </para>
    /// <para>
    /// If the value is positive or negative infinity, it will always be returned as the result
    /// unless <paramref name="maxValue"/> is the opposing infinity (in which case either positive
    /// or negative infinity will be returned randomly).
    /// </para>
    /// </param>
    /// <param name="maxValue">
    /// <para>
    /// The exclusive maximum bound of the random number to be generated.
    /// </para>
    /// <para>
    /// If the value satisfies <see cref="INumberBase{TSelf}.IsNaN(TSelf)"/> the result will be <see
    /// cref="IFloatingPointIeee754{TSelf}.NaN"/>.
    /// </para>
    /// <para>
    /// If the value is positive or negative infinity, it will always be returned as the result
    /// unless <paramref name="minValue"/> is the opposing infinity (in which case either positive
    /// or negative infinity will be returned randomly).
    /// </para>
    /// </param>
    /// <returns>A random, nonnegative floating-point number greater than or equal to <paramref
    /// name="minValue"/> and less than <paramref name="maxValue"/>.</returns>
    /// <remarks>
    /// If <paramref name="minValue"/> is greater than <paramref name="maxValue"/>, the result is
    /// determined by <see cref="RandomizeOptions.InvalidFloatingRangeResult"/>.
    /// </remarks>
    public T Next<T>(ulong index, T minValue, T maxValue) where T : IFloatingPointIeee754<T>
        => SetIndex(index).Next<T>(minValue, maxValue);

    /// <summary>
    /// <para>
    /// Gets a random element from the given <see cref="IList{T}"/>.
    /// </para>
    /// <para>
    /// Each element has an equal chance of being selected. To select elements according to a
    /// weighted ditribution, use <see cref="Next{T}(ulong, IList{T}, Func{T, double})"/>. Note
    /// that if you are generating multiple results, it is more efficient to instead call <see
    /// cref="CategoricalDistributionSamples(ulong, int, ICollection{double})"/> with the
    /// collection of weights as the parameter, and take the results as indexes to selected
    /// items in the <paramref name="list"/>.
    /// </para>
    /// <para>
    /// To select an index rather than an element, use <see cref="NextIndex{T}(ulong,
    /// IList{T})"/>.
    /// </para>
    /// </summary>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <typeparam name="T">The type of elements in the list.</typeparam>
    /// <param name="list">An <see cref="IList{T}"/>.</param>
    /// <returns>
    /// A randomly-selected element from <paramref name="list"/>, or the default value of
    /// <typeparamref name="T"/> if <paramref name="list"/> is <see langword="null"/> or
    /// contains no elements.
    /// </returns>
    /// <remarks>
    /// Note that nullable reference type nullability checking is disabled for the return result
    /// of this method when it is the default type, in order to avoid narrowing the allowable
    /// types to either classes or value types, or splitting the method into differently-named
    /// alternatives for both. As a result, the nullability of the result of this method is not
    /// guaranteed, even though nullable reference type nullability checks are normally enforced
    /// by this library.
    /// </remarks>
    public T Next<T>(ulong index, IList<T>? list) => (list?.Count ?? 0) == 0 ? default! : list![Next(index, list.Count)];

    /// <summary>
    /// <para>
    /// Gets a random element from the given <see cref="IList{T}"/>, where each element has a
    /// weighted chance of selected, given by the function provided.
    /// </para>
    /// <para>
    /// To select elements at random from an unweighted collection, use <see
    /// cref="Next{T}(ulong, IList{T})"/>.
    /// </para>
    /// <para>
    /// Note that if you are generating multiple results, it is more efficient to instead call
    /// <see cref="CategoricalDistributionSamples(ulong, int, ICollection{double})"/> with the
    /// collection of weights as the parameter, and take the results as indexes to selected
    /// items in the <paramref name="list"/>.
    /// </para>
    /// <para>
    /// To select an index rather than an element, use <see cref="NextIndex{T}(ulong, IList{T},
    /// Func{T, double})"/>.
    /// </para>
    /// </summary>
    /// <typeparam name="T">The type of elements in the list.</typeparam>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <param name="list">An <see cref="IList{T}"/>.</param>
    /// <param name="weightFunction">A function which provides a weight, given an element in the
    /// <paramref name="list"/>.</param>
    /// <returns>
    /// A randomly-selected element from <paramref name="list"/>, or the default value of
    /// <typeparamref name="T"/> if <paramref name="list"/> is <see langword="null"/> or
    /// contains no elements.
    /// </returns>
    /// <remarks>
    /// Note that nullable reference type nullability checking is disabled for the return result
    /// of this method when it is the default type, in order to avoid narrowing the allowable
    /// types to either classes or value types, or splitting the method into differently-named
    /// alternatives for both. As a result, the nullability of the result of this method is not
    /// guaranteed, even though nullable reference type nullability checks are normally enforced
    /// by this library.
    /// </remarks>
    public T Next<T>(ulong index, IList<T>? list, Func<T, double> weightFunction)
        => (list?.Count ?? 0) == 0
            ? default!
            : list![GetRandomizer(index).CategoricalDistributionSample(list.Select(weightFunction).ToList())];

    /// <summary>
    /// <para>
    /// Gets a random element from the given <see cref="IEnumerable{T}"/>, in which each
    /// successive item has <paramref name="selectionChance"/> probability of being chosen.
    /// </para>
    /// <para>
    /// Note that this does not result in every item having an equal probability of being
    /// selected. The larger your collection, the lower the probability that items near the end
    /// of the collection will be selected, as each item preceding them will have had a chance
    /// to be selected. To instead select items with equal probability, call <see
    /// cref="Next{T}(ulong, IList{T})"/> on the enumerated elements of your collection.
    /// </para>
    /// </summary>
    /// <typeparam name="T">The type of elements in the list.</typeparam>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <param name="enumerable">An <see cref="IEnumerable{T}"/>.</param>
    /// <param name="selectionChance">
    /// <para>
    /// The probability of selecting any given element. [0, 1]
    /// </para>
    /// <para>
    /// Values less than 0 will be treated as 0, and values greater than 1 will be treated as 1.
    /// </para>
    /// </param>
    /// <returns>
    /// A randomly-selected element from <paramref name="enumerable"/>, or the default value of
    /// <typeparamref name="T"/> if <paramref name="enumerable"/> is <see langword="null"/> or
    /// contains no elements.
    /// </returns>
    /// <remarks>
    /// Note that nullable reference type nullability checking is disabled for the return result
    /// of this method when it is the default type, in order to avoid narrowing the allowable
    /// types to either classes or value types, or splitting the method into differently-named
    /// alternatives for both. As a result, the nullability of the result of this method is not
    /// guaranteed, even though nullable reference type nullability checks are normally enforced
    /// by this library.
    /// </remarks>
    public T Next<T>(ulong index, IEnumerable<T>? enumerable, double selectionChance)
    {
        T current = default!;
        var randomizer = GetRandomizer(index);
        if (enumerable != null)
        {
            foreach (var item in enumerable)
            {
                if (randomizer.NextBool(selectionChance))
                {
                    return item;
                }
                current = item;
            }
        }
        return current;
    }

    /// <summary>
    /// Gets a random boolean value.
    /// </summary>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <returns>A random boolean value.</returns>
    public bool NextBool(ulong index) => GetRandomizer(index).NextBool();

    /// <summary>
    /// Gets a random boolean value with a given probability of selecting <see
    /// langword="true"/>.
    /// </summary>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <param name="probabilityOfTrue">
    /// <para>
    /// The probability that the result will be <see langword="true"/>. [0, 1]
    /// </para>
    /// <para>
    /// Values less than 0 will be treated as 0, and values greater than 1 will be treated as 1.
    /// </para>
    /// </param>
    /// <returns>A random boolean value.</returns>
    public bool NextBool(ulong index, double probabilityOfTrue) => SetIndex(index).NextDouble() <= probabilityOfTrue;

    /// <summary>
    /// Fills the elements of the given <paramref name="buffer" /> with random <see cref="byte" />
    /// values.
    /// </summary>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <param name="buffer">An array of bytes whose values will be randomized.</param>
    /// <exception cref="ArgumentNullException"><paramref name="buffer" /> is null.</exception>
    public void NextBytes(ulong index, byte[] buffer) => GetRandomizer(index).NextBytes(buffer);

    /// <summary>
    /// Fills the elements of the given <see cref="Span{T}"/> with random <see cref="byte" />
    /// values.
    /// </summary>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <param name="buffer">A <see cref="Span{T}"/> of bytes whose values will be
    /// randomized.</param>
    public void NextBytes(ulong index, Span<byte> buffer) => GetRandomizer(index).NextBytes(buffer);

    /// <summary>
    /// Gets a random, nonnegative floating point number less than 1.
    /// </summary>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <returns>A random, nonnegative floating point number less than 1.</returns>
    public decimal NextDecimal(ulong index) => SetIndex(index).NextDecimal();

    /// <summary>
    /// Gets a random floating point number between zero and <paramref name="maxValue"/>.
    /// </summary>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <param name="maxValue">
    /// <para>
    /// The exclusive maximum bound of the random number to be generated.
    /// </para>
    /// <para>
    /// If this value is negative, it is considered an exclusive minimum bound instead (and zero
    /// becomes the inclusive maximum bound).
    /// </para>
    /// <para>
    /// If the value is positive or negative infinity, it will always be returned as the result.
    /// </para>
    /// </param>
    /// <returns>A random, nonnegative floating point number less than <paramref
    /// name="maxValue"/>.</returns>
    public decimal NextDecimal(ulong index, decimal maxValue) => SetIndex(index).NextDecimal(maxValue);

    /// <summary>
    /// Gets a random floating point number greater than or equal to <paramref name="minValue"/>
    /// and less than or equal to <paramref name="maxValue"/>.
    /// </summary>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <param name="minValue">
    /// The inclusive minimum bound of the random number to be generated.
    /// </param>
    /// <param name="maxValue">
    /// The exclusive maximum bound of the random number to be generated.
    /// </param>
    /// <returns>A random floating point number greater than or equal to <paramref
    /// name="minValue"/> and less than <paramref name="maxValue"/>.</returns>
    /// <remarks>
    /// If <paramref name="minValue"/> is greater than <paramref name="maxValue"/>, the result
    /// is determined by <see cref="RandomizeOptions.InvalidIntegralRangeResult"/>.
    /// </remarks>
    public decimal NextDecimal(ulong index, decimal minValue, decimal maxValue) => SetIndex(index).NextDecimal(minValue, maxValue);

    /// <summary>
    /// Gets a random, nonnegative floating point number less than 1.
    /// </summary>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <returns>A random, nonnegative floating point number less than 1.</returns>
    public double NextDouble(ulong index) => SetIndex(index).NextDouble();

    /// <summary>
    /// Gets a random floating point number between zero and <paramref name="maxValue"/>.
    /// </summary>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <param name="maxValue">
    /// <para>
    /// The exclusive maximum bound of the random number to be generated.
    /// </para>
    /// <para>
    /// If this value is negative, it is considered an exclusive minimum bound instead (and zero
    /// becomes the inclusive maximum bound).
    /// </para>
    /// <para>
    /// If the value is <see cref="double.NaN"/> the result will also be <see
    /// cref="double.NaN"/>.
    /// </para>
    /// <para>
    /// If the value is positive or negative infinity, it will always be returned as the result.
    /// </para>
    /// </param>
    /// <returns>A random, nonnegative floating point number less than <paramref
    /// name="maxValue"/>.</returns>
    public double NextDouble(ulong index, double maxValue) => SetIndex(index).NextDouble(maxValue);

    /// <summary>
    /// Gets a random floating point number greater than or equal to <paramref name="minValue"/>
    /// and less than or equal to <paramref name="maxValue"/>.
    /// </summary>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <param name="minValue">
    /// <para>
    /// The inclusive minimum bound of the random number to be generated.
    /// </para>
    /// <para>
    /// If the value is <see cref="double.NaN"/> the result will also be <see
    /// cref="double.NaN"/>.
    /// </para>
    /// <para>
    /// If the value is positive or negative infinity, it will always be returned as the result
    /// unless <paramref name="maxValue"/> is the opposing infinity (in which case either
    /// positive or negative infinity will be returned randomly).
    /// </para>
    /// </param>
    /// <param name="maxValue">
    /// <para>
    /// The exclusive maximum bound of the random number to be generated.
    /// </para>
    /// <para>
    /// If the value is <see cref="double.NaN"/> the result will also be <see
    /// cref="double.NaN"/>.
    /// </para>
    /// <para>
    /// If the value is positive or negative infinity, it will always be returned as the result
    /// unless <paramref name="minValue"/> is the opposing infinity (in which case either
    /// positive or negative infinity will be returned randomly).
    /// </para>
    /// </param>
    /// <returns>A random, nonnegative integer greater than or equal to <paramref
    /// name="minValue"/> and less than <paramref name="maxValue"/>.</returns>
    /// <remarks>
    /// If <paramref name="minValue"/> is greater than <paramref name="maxValue"/>, the result
    /// is determined by <see cref="RandomizeOptions.InvalidFloatingRangeResult"/>.
    /// </remarks>
    public double NextDouble(ulong index, double minValue, double maxValue) => SetIndex(index).NextDouble(minValue, maxValue);

    /// <summary>
    /// Gets a random, nonnegative integer less than or equal to <see cref="int.MaxValue" />.
    /// </summary>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <returns>A random, nonnegative integer less than or equal to <see cref="int.MaxValue"
    /// />.</returns>
    public int NextInclusive(ulong index) => SetIndex(index).NextInclusive();

    /// <summary>
    /// Gets a random integer greater than or equal to zero and less than or equal to <paramref
    /// name="maxValue" />.
    /// </summary>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <param name="maxValue">
    /// <para>
    /// The inclusive maximum bound of the random number to be generated.
    /// </para>
    /// <para>
    /// If this value is negative, it is considered an exclusive minimum bound instead (and zero
    /// becomes the inclusive maximum bound).
    /// </para>
    /// </param>
    /// <returns>A random, nonnegative integer greater than or equal to zero and less than or
    /// equal to <paramref name="maxValue" />.</returns>
    public int NextInclusive(ulong index, int maxValue) => SetIndex(index).NextInclusive(maxValue);

    /// <summary>
    /// Gets a random integer greater than or equal to <paramref name="minValue" /> and less
    /// than or equal to <paramref name="maxValue" />.
    /// </summary>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <param name="minValue">The inclusive minimum bound of the random number to be
    /// generated.</param>
    /// <param name="maxValue">The inclusive maximum bound of the random number to be
    /// generated.</param>
    /// <returns>A random, nonnegative integer greater than or equal to <paramref
    /// name="minValue" /> and less than or equal to <paramref name="maxValue" />.</returns>
    /// <remarks>
    /// If <paramref name="minValue" /> is greater than <paramref name="maxValue" />, the result
    /// is determined by <see cref="RandomizeOptions.InvalidIntegralRangeResult" />.
    /// </remarks>
    public int NextInclusive(ulong index, int minValue, int maxValue) => SetIndex(index).NextInclusive(minValue, maxValue);

    /// <summary>
    /// <para>
    /// Gets a random index to the given <see cref="IList{T}"/>.
    /// </para>
    /// <para>
    /// Each index has an equal chance of being selected. To select an index according to a
    /// weighted ditribution, use <see cref="NextIndex{T}(ulong, IList{T}, Func{T, double})"/>.
    /// Note that if you are generating multiple results, it is more efficient to instead call
    /// <see cref="CategoricalDistributionSamples(ulong, int, ICollection{double})"/> with the
    /// collection of weights as the parameter.
    /// </para>
    /// <para>
    /// To select an element rather than an index, use <see cref="Next{T}(ulong, IList{T})"/>.
    /// </para>
    /// </summary>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <typeparam name="T">The type of elements in the list.</typeparam>
    /// <param name="list">An <see cref="IList{T}"/>.</param>
    /// <returns>
    /// A randomly-selected index to <paramref name="list"/>, or -1 if <paramref name="list"/>
    /// is <see langword="null"/> or contains no elements.
    /// </returns>
    public int NextIndex<T>(ulong index, IList<T>? list) => (list?.Count ?? 0) == 0 ? -1 : Next(index, list!.Count);

    /// <summary>
    /// <para>
    /// Gets a random index to the given <see cref="IList{T}"/>, where each index has a weighted
    /// chance of selected, given by the function provided.
    /// </para>
    /// <para>
    /// To select an index at random from an unweighted collection, use <see
    /// cref="NextIndex{T}(ulong, IList{T})"/>.
    /// </para>
    /// <para>
    /// Note that if you are generating multiple results, it is more efficient to instead call
    /// <see cref="CategoricalDistributionSamples(ulong, int, ICollection{double})"/> with the
    /// collection of weights as the parameter.
    /// </para>
    /// <para>
    /// To select an element rather than an index, use <see cref="Next{T}(ulong, IList{T},
    /// Func{T, double})"/>.
    /// </para>
    /// </summary>
    /// <typeparam name="T">The type of elements in the list.</typeparam>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <param name="list">An <see cref="IList{T}"/>.</param>
    /// <param name="weightFunction">A function which provides a weight, given an element in the
    /// <paramref name="list"/>.</param>
    /// <returns>
    /// A randomly-selected index to <paramref name="list"/>, or -1 if <paramref name="list"/>
    /// is <see langword="null"/> or contains no elements.
    /// </returns>
    public int NextIndex<T>(ulong index, IList<T>? list, Func<T, double> weightFunction) => (list?.Count ?? 0) == 0
        ? -1
        : GetRandomizer(index).CategoricalDistributionSample(list!.Select(weightFunction).ToList());

    /// <summary>
    /// Gets a random, normalized quaternion whose components are floating-point numbers.
    /// </summary>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <returns>
    /// A random, normalized quaternion whose components are floating-point numbers.
    /// </returns>
    /// <remarks>
    /// Each component is selected randomly as a value between 0 and 1, then the result is
    /// normalized. This may cause some form of quasi-Gaussian distribution of results, as the
    /// result is a composite of four independently determined variables, but the
    /// interdependence between components of a quaternion is loose enough that this effect is
    /// considered to be inconsequential.
    /// </remarks>
    public Quaternion<T> NextQuaternion<T>(ulong index) where T : IFloatingPointIeee754<T>
    {
        var randomizer = GetRandomizer(index);
        return Quaternion<T>.Normalize(new Quaternion<T>(
            randomizer.Next<T>(),
            randomizer.Next<T>(),
            randomizer.Next<T>(),
            randomizer.Next<T>()));
    }

    /// <summary>
    /// Gets a random, normalized quaternion whose components are <see cref="double"/> values.
    /// </summary>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <returns>A random, normalized quaternion whose components are <see cref="double"/>
    /// values.</returns>
    /// <remarks>
    /// Each component is selected randomly as a value between 0 and 1, then the result is
    /// normalized. This may cause some form of quasi-Gaussian distribution of results, as the
    /// result is a composite of four independently determined variables, but the
    /// interdependence between components of a quaternion is loose enough that this effect is
    /// considered to be inconsequential.
    /// </remarks>
    public Quaternion<double> NextQuaternionDouble(ulong index)
    {
        var randomizer = GetRandomizer(index);
        return Quaternion<double>.Normalize(new Quaternion<double>(
            randomizer.NextDouble(),
            randomizer.NextDouble(),
            randomizer.NextDouble(),
            randomizer.NextDouble()));
    }

    /// <summary>
    /// Gets a random, unsigned integer less than <see cref="uint.MaxValue" />.
    /// </summary>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <returns>A random, unsigned integer less than <see cref="uint.MaxValue" />.</returns>
    public uint NextUInt(ulong index) => SetIndex(index).NextUInt();

    /// <summary>
    /// Gets a random, unsigned integer less than <paramref name="maxValue" />.
    /// </summary>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <param name="maxValue">The exclusive maximum bound of the random number to be
    /// generated.</param>
    /// <returns>A random, unsigned integer less than <paramref name="maxValue" />.</returns>
    public uint NextUInt(ulong index, uint maxValue) => SetIndex(index).NextUInt(maxValue);

    /// <summary>
    /// Gets a random, unsigned integer greater than or equal to <paramref name="minValue" />
    /// and less than <paramref name="maxValue" />.
    /// </summary>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <param name="minValue">The inclusive minimum bound of the random number to be
    /// generated.</param>
    /// <param name="maxValue">The exclusive maximum bound of the random number to be
    /// generated.</param>
    /// <returns>A random integer greater than or equal to <paramref name="minValue" /> and less
    /// than <paramref name="maxValue" />.</returns>
    /// <remarks>
    /// If <paramref name="minValue" /> is greater than <paramref name="maxValue" />, the result
    /// is determined by <see cref="RandomizeOptions.InvalidIntegralRangeResult" />.
    /// </remarks>
    public uint NextUInt(ulong index, uint minValue, uint maxValue) => SetIndex(index).NextUInt(minValue, maxValue);

    /// <summary>
    /// Gets a random, unsigned integer less than or equal to <see cref="uint.MaxValue" />.
    /// </summary>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <returns>A random, unsigned integer less than or equal to <see cref="uint.MaxValue"
    /// />.</returns>
    public uint NextUIntInclusive(ulong index) => SetIndex(index).NextUIntInclusive();

    /// <summary>
    /// Gets a random integer greater than or equal to zero and less than or equal to <paramref
    /// name="maxValue" />.
    /// </summary>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <param name="maxValue">
    /// <para>
    /// The inclusive maximum bound of the random number to be generated.
    /// </para>
    /// </param>
    /// <returns>A random, nonnegative integer greater than or equal to zero and less than or
    /// equal to <paramref name="maxValue" />.</returns>
    public uint NextUIntInclusive(ulong index, uint maxValue) => SetIndex(index).NextUIntInclusive(maxValue);

    /// <summary>
    /// Gets a random, unsigned integer greater than or equal to <paramref name="minValue" />
    /// and less than or equal to <paramref name="maxValue" />.
    /// </summary>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <param name="minValue">The inclusive minimum bound of the random number to be
    /// generated.</param>
    /// <param name="maxValue">The inclusive maximum bound of the random number to be
    /// generated.</param>
    /// <returns>A random integer greater than or equal to <paramref name="minValue" /> and less
    /// than or equal to <paramref name="maxValue" />.</returns>
    /// <remarks>
    /// If <paramref name="minValue" /> is greater than <paramref name="maxValue" />, the result
    /// is determined by <see cref="RandomizeOptions.InvalidIntegralRangeResult" />.
    /// </remarks>
    public uint NextUIntInclusive(ulong index, uint minValue, uint maxValue) => SetIndex(index).NextUIntInclusive(minValue, maxValue);

    /// <summary>
    /// Gets a randomly oriented vector whose length is between 0 and <paramref name="maxLength"/>,
    /// and whose components are floating-point numbers.
    /// </summary>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <param name="maxLength">
    /// <para>
    /// The exclusive upper bound of the length of the vector to be generated.
    /// </para>
    /// <para>
    /// Values below zero will be treated as zero.
    /// </para>
    /// <para>
    /// <see cref="IFloatingPointIeee754{TSelf}.PositiveInfinity"/> will always result in an
    /// infinite-length vector.
    /// </para>
    /// </param>
    /// <returns>
    /// A randomly oriented vector whose length is between 0 and <paramref name="maxLength"/>, and
    /// whose components are floating-point numbers.
    /// </returns>
    /// <remarks>
    /// A random rotation is generated with <see cref="Randomizer.NextQuaternion{T}()"/>, then the
    /// vector is scaled randomly according to <paramref name="maxLength"/>, to avoid
    /// unintentionally generating lengths in a quasi-Gaussian distribution, as would occur if the
    /// vector components were generated independently.
    /// </remarks>
    public Vector3<T> NextVector3<T>(ulong index, T maxLength) where T : IFloatingPointIeee754<T>
    {
        var randomizer = GetRandomizer(index);
        return Vector3<T>.Transform(
            Vector3<T>.UnitX,
            randomizer.NextQuaternion<T>()) * randomizer.Next<T>(maxLength);
    }

    /// <summary>
    /// Gets a randomly oriented vector whose length is between <paramref name="minLength"/> and
    /// <paramref name="maxLength"/>, and whose components are floating-point numbers.
    /// </summary>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <param name="minLength">The inclusive lower bound of the length of the vector to be
    /// generated.</param>
    /// <param name="maxLength">
    /// The exclusive upper bound of the length of the vector to be generated.
    /// </param>
    /// <returns>
    /// A randomly oriented vector whose length is between <paramref name="minLength"/>
    /// and <paramref name="maxLength"/>, and whose components are floating-point numbers.
    /// </returns>
    /// <remarks>
    /// <para>
    /// A random rotation is generated with <see cref="Randomizer.NextQuaternion{T}()"/>,
    /// then the vector is scaled randomly according to <paramref name="minLength"/> and
    /// <paramref name="maxLength"/>, to avoid unintentionally generating lengths in a
    /// quasi-Gaussian distribution, as would occur if the vector components were generated
    /// independently.
    /// </para>
    /// <para>
    /// If <paramref name="minLength"/> is greater than <paramref name="maxLength"/>, the result
    /// is determined by <see cref="RandomizeOptions.InvalidIntegralRangeResult"/>.
    /// </para>
    /// </remarks>
    public Vector3<T> NextVector3<T>(ulong index, T minLength, T maxLength) where T : IFloatingPointIeee754<T>
    {
        var randomizer = GetRandomizer(index);
        return Vector3<T>.Transform(
            Vector3<T>.UnitX,
            randomizer.NextQuaternion<T>()) * randomizer.Next<T>(minLength, maxLength);
    }

    /// <summary>
    /// Gets a randomly oriented vector whose length is between 0 and <paramref
    /// name="maxLength"/>, and whose components are <see cref="double"/> values.
    /// </summary>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <param name="maxLength">
    /// <para>
    /// The exclusive upper bound of the length of the vector to be generated.
    /// </para>
    /// <para>
    /// Values below zero will be treated as zero.
    /// </para>
    /// <para>
    /// <see cref="double.PositiveInfinity"/> will always result in an infinite-length vector.
    /// </para>
    /// </param>
    /// <returns>A randomly oriented vector whose length is between 0 and <paramref
    /// name="maxLength"/>, and whose components are <see cref="double"/> values.</returns>
    /// <remarks>
    /// A random rotation is generated with <see cref="Randomizer.NextQuaternionDouble()"/>,
    /// then the vector is scaled randomly according to <paramref name="maxLength"/>, to avoid
    /// unintentionally generating lengths in a quasi-Gaussian distribution, as would occur if
    /// the vector components were generated independently.
    /// </remarks>
    public Vector3<double> NextVector3Double(ulong index, double maxLength)
    {
        var randomizer = GetRandomizer(index);
        return Vector3<double>.Transform(
            Vector3<double>.UnitX,
            randomizer.NextQuaternionDouble()) * randomizer.NextDouble(maxLength);
    }

    /// <summary>
    /// Gets a randomly oriented vector whose length is between <paramref name="minLength"/> and
    /// <paramref name="maxLength"/>, and whose components are <see cref="double"/> values.
    /// </summary>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <param name="minLength">The inclusive lower bound of the length of the vector to be
    /// generated.</param>
    /// <param name="maxLength">
    /// The exclusive upper bound of the length of the vector to be generated.
    /// </param>
    /// <returns>A randomly oriented vector whose length is between <paramref name="minLength"/>
    /// and <paramref name="maxLength"/>, and whose components are <see cref="double"/>
    /// values.</returns>
    /// <remarks>
    /// <para>
    /// A random rotation is generated with <see cref="Randomizer.NextQuaternionDouble()"/>,
    /// then the vector is scaled randomly according to <paramref name="minLength"/> and
    /// <paramref name="maxLength"/>, to avoid unintentionally generating lengths in a
    /// quasi-Gaussian distribution, as would occur if the vector components were generated
    /// independently.
    /// </para>
    /// <para>
    /// If <paramref name="minLength"/> is greater than <paramref name="maxLength"/>, the result
    /// is determined by <see cref="RandomizeOptions.InvalidIntegralRangeResult"/>.
    /// </para>
    /// </remarks>
    public Vector3<double> NextVector3Double(ulong index, double minLength, double maxLength)
    {
        var randomizer = GetRandomizer(index);
        return Vector3<double>.Transform(
            Vector3<double>.UnitX,
            randomizer.NextQuaternionDouble()) * randomizer.NextDouble(minLength, maxLength);
    }

    /// <summary>
    /// <para>
    /// Gets a sample pseudo-random value from a normal distribution.
    /// </para>
    /// <para>
    /// When generating multiple values, use <see cref="NormalDistributionSamples(ulong, int,
    /// double, double, double?, double?)"/>.
    /// </para>
    /// </summary>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <param name="mu">
    /// <para>
    /// The location (mean) of the distribution.
    /// </para>
    /// <para>
    /// If <see cref="double.NaN"/>, all results will be <see cref="double.NaN"/>.
    /// </para>
    /// </param>
    /// <param name="sigma">
    /// <para>
    /// The standard deviation of the distribution. (0, ∞)
    /// </para>
    /// <para>
    /// If <see cref="double.NaN"/>, all results will be <see cref="double.NaN"/>.
    /// </para>
    /// <para>
    /// If less than or equal to zero, will be set to the smallest value recognized as greater
    /// than zero in this library (<see cref="NumberValues.NearlyZeroDouble"/>).
    /// </para>
    /// </param>
    /// <param name="minimum">
    /// <para>
    /// A minimum value. Does not affect the shape of the function, but results less than this
    /// value will not be generated.
    /// </para>
    /// </param>
    /// <param name="maximum">
    /// <para>
    /// A maximum value. Does not affect the shape of the function, but results greater than
    /// this value will not be generated.
    /// </para>
    /// </param>
    /// <returns>A sample value from a normal distribution.</returns>
    /// <remarks>
    /// If <paramref name="minimum"/> and <paramref name="maximum"/> are both non-<see
    /// langword="null"/> and <paramref name="minimum" /> is greater than <paramref
    /// name="maximum" />, the result is determined by <see
    /// cref="RandomizeOptions.InvalidFloatingRangeResult" />.
    /// </remarks>
    public double NormalDistributionSample(
        ulong index,
        double mu = 0,
        double sigma = 1,
        double? minimum = null,
        double? maximum = null)
        => GetRandomizer(index).NormalDistributionSample(mu, sigma, minimum, maximum);

    /// <summary>
    /// Enumerates sample pseudo-random values from a normal distribution.
    /// </summary>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <param name="numberOfSamples">
    /// <para>
    /// The number of sample values to generate. This parameter ensures that operations like
    /// <see cref="Enumerable.ToList"/> will not cause an overflow, by preventing an
    /// infinite enumeration. If more than <see cref="int.MaxValue"/> samples are required, this
    /// method can be called again to "refresh" the count.
    /// </para>
    /// <para>
    /// Values less than zero will be treated as zero.
    /// </para>
    /// </param>
    /// <param name="mu">
    /// <para>
    /// The location (mean) of the distribution.
    /// </para>
    /// <para>
    /// If <see cref="double.NaN"/>, all results will be <see cref="double.NaN"/>.
    /// </para>
    /// </param>
    /// <param name="sigma">
    /// <para>
    /// The standard deviation of the distribution. (0, ∞)
    /// </para>
    /// <para>
    /// If <see cref="double.NaN"/>, all results will be <see cref="double.NaN"/>.
    /// </para>
    /// <para>
    /// If less than or equal to zero, will be set to the smallest value recognized as greater
    /// than zero in this library (<see cref="NumberValues.NearlyZeroDouble"/>).
    /// </para>
    /// </param>
    /// <param name="minimum">
    /// <para>
    /// A minimum value. Does not affect the shape of the function, but results less than this
    /// value will not be generated.
    /// </para>
    /// </param>
    /// <param name="maximum">
    /// <para>
    /// A maximum value. Does not affect the shape of the function, but results greater than
    /// this value will not be generated.
    /// </para>
    /// </param>
    /// <returns>An <see cref="IEnumerable{T}"/> of sample values from a normal
    /// distribution.</returns>
    /// <remarks>
    /// If <paramref name="minimum"/> and <paramref name="maximum"/> are both non-<see
    /// langword="null"/> and <paramref name="minimum" /> is greater than <paramref
    /// name="maximum" />, the result is determined by <see
    /// cref="RandomizeOptions.InvalidFloatingRangeResult" />.
    /// </remarks>
    public IEnumerable<double> NormalDistributionSamples(
        ulong index,
        int numberOfSamples = 1,
        double mu = 0,
        double sigma = 1,
        double? minimum = null,
        double? maximum = null)
        => GetRandomizer(index).NormalDistributionSamples(numberOfSamples, mu, sigma, minimum, maximum);

    /// <summary>
    /// <para>
    /// Gets a sample pseudo-random value from the positive half of a normal distribution.
    /// </para>
    /// <para>
    /// When generating multiple values, use <see cref="NormalDistributionSamples(ulong, int,
    /// double, double, double?, double?)"/>.
    /// </para>
    /// </summary>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <param name="mu">
    /// <para>
    /// The location (mean) of the distribution.
    /// </para>
    /// <para>
    /// If <see cref="double.NaN"/>, all results will be <see cref="double.NaN"/>.
    /// </para>
    /// </param>
    /// <param name="sigma">
    /// <para>
    /// The standard deviation of the distribution. (0, ∞)
    /// </para>
    /// <para>
    /// If <see cref="double.NaN"/>, all results will be <see cref="double.NaN"/>.
    /// </para>
    /// <para>
    /// If less than or equal to zero, will be set to the smallest value recognized as greater
    /// than zero in this library (<see cref="NumberValues.NearlyZeroDouble"/>).
    /// </para>
    /// </param>
    /// <param name="maximum">
    /// <para>
    /// A maximum value. Does not affect the shape of the function, but results greater than
    /// this value will not be generated.
    /// </para>
    /// </param>
    /// <returns>A sample value from the positive half of a normal distribution.</returns>
    public double PositiveNormalDistributionSample(
        ulong index,
        double mu = 0,
        double sigma = 1,
        double? maximum = null)
        => GetRandomizer(index).PositiveNormalDistributionSample(mu, sigma, maximum);

    /// <summary>
    /// Enumerates sample pseudo-random values from the positive half of a normal distribution.
    /// </summary>
    /// <param name="index">The 0-based index of the random value to retrieve.</param>
    /// <param name="numberOfSamples">
    /// <para>
    /// The number of sample values to generate. This parameter ensures that operations like
    /// <see cref="Enumerable.ToList"/> will not cause an overflow, by preventing an infinite
    /// enumeration. If more than <see cref="int.MaxValue"/> samples are required, this method
    /// can be called again to "refresh" the count.
    /// </para>
    /// <para>
    /// Values less than zero will be treated as zero.
    /// </para>
    /// </param>
    /// <param name="mu">
    /// <para>
    /// The location (mean) of the distribution.
    /// </para>
    /// <para>
    /// If <see cref="double.NaN"/>, all results will be <see cref="double.NaN"/>.
    /// </para>
    /// </param>
    /// <param name="sigma">
    /// <para>
    /// The standard deviation of the distribution. (0, ∞)
    /// </para>
    /// <para>
    /// If <see cref="double.NaN"/>, all results will be <see cref="double.NaN"/>.
    /// </para>
    /// <para>
    /// If less than or equal to zero, will be set to the smallest value recognized as greater
    /// than zero in this library (<see cref="NumberValues.NearlyZeroDouble"/>).
    /// </para>
    /// </param>
    /// <param name="maximum">
    /// <para>
    /// A maximum value. Does not affect the shape of the function, but results greater than
    /// this value will not be generated.
    /// </para>
    /// </param>
    /// <returns>An <see cref="IEnumerable{T}"/> of sample values from the positive half of a
    /// normal distribution.</returns>
    public IEnumerable<double> PositiveNormalDistributionSamples(
        ulong index,
        int numberOfSamples = 1,
        double mu = 0,
        double sigma = 1,
        double? maximum = null)
        => GetRandomizer(index).PositiveNormalDistributionSamples(numberOfSamples, mu, sigma, maximum);

    private Randomizer GetRandomizer(ulong index) => new(SetIndex(index).NextUIntInclusive());

    private Randomizer SetIndex(ulong index)
    {
        if (index < _index)
        {
            _index = 0;
        }
        while (_index < index)
        {
            _randomizer.NextUIntInclusive();
            _index++;
        }
        _index++;
        return _randomizer;
    }
}
